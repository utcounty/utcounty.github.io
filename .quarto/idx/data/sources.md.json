{"title":"**Data Sources**","markdown":{"headingText":"**Data Sources**","containsRefs":false,"markdown":"\n## Utah VISTA Ballot Areas Precinct Boundaries:\nStatewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\n* **Dataset**: Utah VISTA Ballot Areas\n* **URL**: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\n* **Original file**: VistaBallotAreas_-1176372527926423573.geojson\n\n**Processing**:\n\n* Load the statewide GeoJSON\n* Filter to Utah County using `CountyID == 25`:\n* Keep only required fields: `['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']`\n* Reproject for web mapping: `WGS84 (EPSG:4326) `\n* Lightly simplify geometry for performance: `tolerance = 0.0001`\n\n**Output**:\ndata/geo/utah_county_precincts.min.geojson\n\n## 2025-11-04 Utah County Municipal General Election *(JSON data)*\n* **Link**: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters (Under: Utah Election Night Reporting Media Export)\n* **File Name**: 20251104_utah_county_municipal_general_election.json\n* **Original File Name**: export-general11042025.json\n\n## 2025 Utah Municipal General Election: Voter Turnout *(HTML data)*\n* **Link**: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters\n* **File Name**: utah-county-ut_elections_general11042025_voters_body.html\n\n## 2025-08-12 Utah County Municipal Primary *(JSON data)*\n* **Link**: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters (Under: Utah Election Night Reporting Media Export)\n* **File Name**: 20250812_utah_county_municipal_primary_election.json\n* **Original File Name**: export-primary08122025.json\n\n## 2025 Utah Municipal Primary: Voter Turnout *(HTML data)*\n* **Link**: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters\n* **File Name**: utah-county-ut_elections_primary08122025_voters_body.html\n\n## utah_county_elections.csv\n\nThis CSV is the output of **election_parsing.py**:\n\n```python\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nimport numpy as np\nimport json\n\n###########\n\ndef parse_election_html(path, election_name):\n    soup = BeautifulSoup(Path(path).read_text(encoding=\"utf-8\"), \"html.parser\")\n\n    table = soup.select_one(\"table\")\n\n    def to_num(s: str):\n        s = re.sub(r\"[^0-9.-]\", \"\", re.sub(r\"[,\\u00A0]\", \"\", s.strip()))\n        return None if not s or s == \".\" else (float(s) if \".\" in s else int(s))\n\n    cols = [th.get_text(\" \", strip=True) for th in table.select(\"thead th\")][:4]\n\n    rows = []\n    for tr in table.select(\"tbody tr\"):\n        precinct = tr.find(\"th\", scope=\"row\").get_text(\" \", strip=True)\n\n        tds = tr.find_all(\"td\")[:3]\n        nums = [to_num(td.get_text(\" \", strip=True)) for td in tds]\n\n        rows.append([precinct, *nums])\n\n    df = pd\\\n        .DataFrame(\n            rows, \n            columns=[\"_\".join(c.lower().split()) for c in cols])\\\n        .assign(election_name = election_name)\\\n        .rename(columns={\n            \"precinct\": \"precinct_code\",\n            \"ballots_cast\": \"precinct_ballots_cast\",\n            \"registered_voters\": \"precinct_registered_voters\"})\n\n    return df\n\ndef parse_election_json(path, county=\"Utah County\"):\n\n    JSON = json.loads(Path(path).read_text(encoding=\"utf-8-sig\"))\n\n    def as_list(x):\n        return x if isinstance(x, list) else []\n\n    rows = []\n\n    for county in as_list(JSON.get(\"localResults\")):\n        if not isinstance(county, dict):\n            continue\n\n        county_id = county.get(\"id\")\n        county_name = county.get(\"name\")\n\n        for contest in as_list(county.get(\"ballotItems\")):\n            if not isinstance(contest, dict):\n                continue\n\n            contest_id = contest.get(\"id\")\n            contest_name = contest.get(\"name\")\n            contest_type = contest.get(\"type\")\n            contest_vote_for = contest.get(\"voteFor\")\n            contest_ballot_order = contest.get(\"ballotOrder\")\n\n            for opt in as_list(contest.get(\"ballotOptions\")):\n                if not isinstance(opt, dict):\n                    continue\n\n                opt_core = {\n                    \"election_date\": JSON.get(\"electionDate\"),\n                    \"election_name\": JSON.get(\"electionName\"),\n                    \"county_id\": county_id,\n                    \"county_name\": county_name,\n                    \"contest_id\": contest_id,\n                    \"contest_name\": contest_name,\n                    \"contest_type\": contest_type,\n                    \"contest_vote_for\": contest_vote_for,\n                    \"contest_ballot_order\": contest_ballot_order,\n                    \"choice_id\": opt.get(\"id\"),\n                    \"choice_name\": opt.get(\"name\"),\n                    \"choice_ballot_order\": opt.get(\"ballotOrder\"),\n                    \"choice_votes\": opt.get(\"voteCount\"),\n                    \"choice_party\": opt.get(\"politicalParty\") or None,\n                }\n\n                for pr in as_list(opt.get(\"precinctResults\")):\n                    if not isinstance(pr, dict):\n                        continue\n                    rows.append({**opt_core, **pr})\n\n    return pd\\\n        .DataFrame(rows)\\\n        .pipe(lambda df:\n            pd.json_normalize(df.to_dict(orient=\"records\"), sep=\".\"))\\\n        .rename({\n            \"name\": \"precinct_code\",\n            \"voteCount\": \"precinct_votes\"}, axis=1)\\\n        .filter(items=[\n            \"election_date\",\n            \"election_name\",\n            \"county_name\",\n            \"contest_name\",\n            \"contest_type\",\n            \"choice_name\",\n            \"precinct_code\",\n            \"precinct_votes\"])\n\ndef add_turnout_metrics(df):\n    return df\\\n    .assign(\n        is_zero_registration_precinct = pd.col(\"voter_registration\").eq(0),\n        is_zero_ballots_precinct = pd.col(\"precinct_ballots_cast\").eq(0),\n        turnout_rate_precinct = pd.col(\"voter_turnout\") / pd.col(\"voter_registration\"))\\\n    .assign(\n        turnout_rate_pct_precinct = pd.col(\"turnout_rate_precinct\").rank(pct=True, method=\"average\", na_option=\"keep\"))\n\ndef add_election_metrics(df):\n    return df\\\n        .assign(\n\n            # --- Contest vote distribution (per contest × precinct) ---\n            contest_total_votes=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"sum\"),\n\n            choice_share=(\n                (pd.col(\"precinct_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") > 0)),\n\n            choice_rank=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].rank(method=\"dense\", ascending=False),\n\n            polarization_fragmentation=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\n                    lambda s: (1 - np.square(s / s.sum()).sum()) if s.sum() > 0 else np.nan)),\n\n            # --- Contest engagement (ballots that participated in the contest) ---\n            contest_participation_rate=(\n                (pd.col(\"contest_total_votes\") / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") > 0)),\n            rolloff_count=(\n                (pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"precinct_ballots_cast\") > 0)),\n            rolloff_rate=(\n                ((pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\")) / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") > 0)),\n\n            # --- Outcome summary (winner / runner-up / margins) ---\n            winner_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"max\")\n                .where(d[\"contest_total_votes\"] > 0)),\n            runnerup_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"]\n                .transform(lambda s: (s.nlargest(2).iloc[1] if len(s) > 1 else 0))\n                .where(d[\"contest_total_votes\"] > 0)),\n\n            margin_votes=(\n                (pd.col(\"winner_votes\") - pd.col(\"runnerup_votes\"))\n                .where(pd.col(\"contest_total_votes\") > 0)),\n            margin_pct=(\n                (pd.col(\"margin_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") > 0)),\n            winner_share=(\n                (pd.col(\"winner_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") > 0)),\n            runnerup_share=(\n                (pd.col(\"runnerup_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") > 0)),\n\n            # --- Human-readable labels (ties become \"A | B\") ---\n            winner_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 1)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)),\n            runnerup_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 2)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)))\\\n        .sort_values(KEYS_PC + [\"precinct_votes\"], ascending=[True, True, True, True, False])\n\n###########\n\ndf_primary_json = parse_election_json(r\"20250812_utah_county_municipal_primary_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_general_json = parse_election_json(r\"20251104_utah_county_municipal_general_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_primary_totals = parse_election_html(r\"utah-county-ut_elections_primary08122025_voters_body.html\", \"2025 Utah Municipal Primary\")\\\n    .pipe(add_turnout_metrics)\n\ndf_general_totals = parse_election_html(r\"utah-county-ut_elections_general11042025_voters_body.html\", \"2025 Utah Municipal General Election\")\\\n    .pipe(add_turnout_metrics)\n\n\n###########\n\nKEYS_PC = [\"election_name\", \"county_name\", \"contest_name\", \"precinct_code\"]\n\ndf_general = df_general_json\\\n    .merge(\n        df_general_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n    \ndf_primary = df_primary_json\\\n    .merge(\n        df_primary_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n\n###########\n\nutah_county_elections = pd.concat([df_primary, df_general], ignore_index=True)\n\nutah_county_elections.to_csv(\"utah_county_elections.csv\", index=False)\n```\n\n#### Output column definitions:\n\n**Grain:** Each row represents **one `choice_name` (candidate / YES / NO / etc.) within one `contest_name` within one `precinct_code`** for a given `election_name`.  \nBecause of that grain, precinct-wide totals (like registration, ballots cast) and contest-wide totals (like `contest_total_votes`) **repeat across multiple rows** (one per choice).\n\n#### Election identifiers\n\n- **`election_date`** *(str)*  \n  Date of the election in `YYYY-MM-DD` form (as provided by the source).  \n  Example: `2025-11-04`.\n\n- **`election_name`** *(str)*  \n  Human-readable election label (as provided by the source).  \n  Example: `2025 Utah Municipal General Election`.\n\n- **`county_name`** *(str)*  \n  County label (`\"Utah County\"` here).\n\n\n#### Contest & choice identifiers\n\n- **`contest_name`** *(str)*  \n  The race/measure name as shown in results.  \n  Examples: `\"Saratoga Springs Mayor\"`, `\"School Board Lake Mountain 5\"`, `\"Proposition #8 Eagle Mountain\"`.\n\n- **`contest_type`** *(str)*  \n  High-level contest category from the source (often `\"Local\"` in municipal datasets).\n\n- **`choice_name`** *(str)*  \n  The selectable option within a contest (candidate name, `\"YES\"`, `\"NO\"`, write-in bucket, etc.).\n\n#### Precinct identifiers\n\n- **`precinct_code`** *(str)*  \n  Precinct identifier used to join precinct-level results and turnout totals.  \n  Example: `\"25SR15\"`.\n\n#### Raw vote and turnout totals (from source / merge)\n\n- **`precinct_votes`** *(int)*  \n  Votes recorded **for this specific `choice_name`** in this precinct for this contest.  \n  (This is the numerator for `choice_share`.)\n\n- **`precinct_ballots_cast`** *(int)*  \n  Total ballots cast in the precinct for the election (precinct-wide).  \n  **Repeats** for all rows belonging to that precinct within the election.\n\n- **`voter_turnout`** *(int)*  \n  Turnout count for the precinct (precinct-wide).  \n  In many exports this equals `precinct_ballots_cast`; if they differ, treat `voter_turnout` as the official turnout figure.\n\n- **`voter_registration`** *(int)*  \n  Registered voters in the precinct (precinct-wide).\n\n#### Data quality flags\n\n- **`is_zero_registration_precinct`** *(bool)*  \n  Convenience flag:  \n  `voter_registration == 0`  \n  Useful to avoid divide-by-zero and to quickly locate placeholder/invalid precinct records.\n\n- **`is_zero_ballots_precinct`** *(bool)*  \n  Convenience flag:  \n  `precinct_ballots_cast == 0`  \n  Useful to identify precincts with no reported ballots or incomplete reporting.\n\n#### Precinct-wide turnout rates (precinct-wide; repeats per row)\n\n- **`turnout_rate_precinct`** *(float)*  \n  Turnout fraction in the precinct:  \n  `turnout_rate_precinct = voter_turnout / voter_registration`  \n  Typically `NaN` (or undefined) if `voter_registration == 0`.\n\n- **`turnout_rate_pct_precinct`** *(float)*  \n  Percent form of turnout:  \n  `turnout_rate_pct_precinct = 100 * turnout_rate_precinct`\n\n\n#### Contest vote distribution (per contest × precinct; repeats per choice row)\n\n- **`contest_total_votes`** *(int)*  \n  Total votes recorded in this contest in this precinct, across all choices:  \n  `contest_total_votes = Σ precinct_votes` over all `choice_name` within the same  \n  (`election_name`, `county_name`, `contest_name`, `precinct_code`) group.\n\n  **Interpretation note:** For multi-seat contests (e.g., “vote for up to 2”), `contest_total_votes` can be **greater than** `precinct_ballots_cast`.\n\n- **`choice_share`** *(float)*  \n  Share of the contest vote for this choice in this precinct:  \n  `choice_share = precinct_votes / contest_total_votes` (when `contest_total_votes > 0`).\n\n- **`choice_rank`** *(float)*  \n  Rank of this choice by `precinct_votes` within the contest/precinct group (dense ranking, descending):  \n  `choice_rank = rank_dense_desc(precinct_votes within group)`  \n  - `1` = top vote-getter(s)  \n  - Ties share the same rank  \n  - Next rank increments by 1 (dense)\n\n- **`polarization_fragmentation`** *(float)*  \n  A concentration/fragmentation index derived from vote shares (Simpson-style):  \n  Let `p_i = precinct_votes_i / contest_total_votes` for each choice in the group.  \n  Then:  \n  `polarization_fragmentation = 1 - Σ(p_i^2)`  (when `contest_total_votes > 0`)\n\n  Interpretation:\n  - Near **0** → highly concentrated (one option dominates)\n  - Larger values → more fragmented (votes spread across options)\n  - Maximum depends on number of choices (more choices can raise the maximum)\n\n#### Contest engagement (ballots that “touched” the contest)\n\nThese are computed using `precinct_ballots_cast` as a denominator.\n\n- **`contest_participation_rate`** *(float)*  \n  Rate of ballots that recorded a vote in the contest (proxy):  \n  `contest_participation_rate = contest_total_votes / precinct_ballots_cast` (when `precinct_ballots_cast > 0`)\n\n  **Important interpretation note:**  \n  This behaves as expected for **single-choice** contests (mayor, proposition yes/no, etc.).  \n  For **multi-seat** contests, `contest_total_votes` can exceed `precinct_ballots_cast`, so this can be **> 1** and should be interpreted as “votes per ballot” rather than “participation.”\n\n- **`rolloff_count`** *(float)*  \n  Ballots that did *not* record a vote in this contest (proxy):  \n  `rolloff_count = precinct_ballots_cast - contest_total_votes` (when `precinct_ballots_cast > 0`)\n\n  **Note:** Can be **negative** in multi-seat contests (because `contest_total_votes` may exceed ballots cast).  \n  If you want a “never negative” roll-off for mapping, a common variant is:  \n  `rolloff_count_clipped = max(rolloff_count, 0)`.\n\n- **`rolloff_rate`** *(float)*  \n  Roll-off fraction:  \n  `rolloff_rate = rolloff_count / precinct_ballots_cast` (when `precinct_ballots_cast > 0`)  \n  Same caveat: may be negative for multi-seat contests.\n\n#### Outcome summary (winner / runner-up / margins)\n\nThese values repeat for every `choice_name` row inside the same contest/precinct group.\n\n- **`winner_votes`** *(float)*  \n  Top vote total in the contest/precinct group:  \n  `winner_votes = max(precinct_votes within group)` (when `contest_total_votes > 0`)\n\n- **`runnerup_votes`** *(float)*  \n  Second-highest vote total in the group:  \n  `runnerup_votes = 2nd_largest(precinct_votes within group)` (when `contest_total_votes > 0`)\n\n  Edge case:\n  - If the contest has only one reported choice in the group, this may be set to `0` (or could be `NaN` depending on implementation preference).\n\n- **`margin_votes`** *(float)*  \n  Vote margin between the top two choices:  \n  `margin_votes = winner_votes - runnerup_votes` (when `contest_total_votes > 0`)\n\n- **`margin_pct`** *(float)*  \n  Margin as a fraction of contest votes:  \n  `margin_pct = margin_votes / contest_total_votes` (when `contest_total_votes > 0`)\n\n- **`winner_share`** *(float)*  \n  Winner’s share of the contest vote:  \n  `winner_share = winner_votes / contest_total_votes` (when `contest_total_votes > 0`)\n\n- **`runnerup_share`** *(float)*  \n  Runner-up’s share of the contest vote:  \n  `runnerup_share = runnerup_votes / contest_total_votes` (when `contest_total_votes > 0`)\n\n- **`winner_choice_name`** *(str)*  \n  Name(s) of the winning choice(s) in that contest/precinct group.  \n  Computed by selecting `choice_name` where `choice_rank == 1`.  \n  If there is a tie for first, names may be joined like: `\"A | B\"`.\n\n- **`runnerup_choice_name`** *(object / str; may contain NaN)*  \n  Name(s) of the 2nd-place choice(s) in that contest/precinct group.  \n  Computed by selecting `choice_name` where `choice_rank == 2`.  \n  Can be `NaN` when there is no runner-up (e.g., uncontested contests or only one reported choice).\n\n**Note**:\nFor multi-seat contests (like many \"City Council\" contests), you may observe:\n- `contest_total_votes > precinct_ballots_cast`\n- therefore `rolloff_count < 0` and `rolloff_rate < 0`\n\nThis does **not** necessarily indicate bad data; it usually means the contest allows selecting multiple candidates (so ballots can contribute multiple votes).\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles/styles.css"],"output-file":"sources.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}