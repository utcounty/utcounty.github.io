[
  {
    "objectID": "blog/metric.html",
    "href": "blog/metric.html",
    "title": "Understanding Precinct Level Data",
    "section": "",
    "text": "Domain Knowledge\n\n  \n  \n      \n        \n\n          \n          \n            \n              The Precinct\n              \n                The smallest political unit in the election. It is a specific geographic shape (polygon).\n                Everyone living inside this shape votes at the same location (or gets the same ballot style).\n              \n            \n\n            \n              \n                \n                  State (Utah)\n                \n              \n\n              \n              \n                County (Utah County)\n\n\n                \n                  \n                    Precinct\n                  \n\n                  \n                    \n                      Ballot Style\n                    \n                    \n                    \n                      Contest / Race\n                      appears on ballot\n                    \n                    \n                  \n\n                \n              \n\n              \n                Think of it as: State → County → Precinct → Ballot Style → Contest\n              \n            \n\n          \n\n          \n          \n            \n\n              \n              \n                \n                  County\n                \n              \n\n              \n              \n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n\n                \n                \n                  Precinct\n                \n              \n            \n          \n        \n      \n\n\n    \n    \n      \n        Registration vs. Turnout\n        Understanding the subset of people who actually generate data.\n      \n\n      \n\n        \n          \n            \n              1,000\n            \n          \n          voter_registration\n          People legally allowed to vote within the precinct.\n        \n\n        \n          \n            \n              400\n            \n          \n          voter_turnout\n          People who submitted a ballot within the precinct.\n        \n\n        \n          \n            \n              350\n              \n                ↓ Drop-off (Rolloff)\n              \n            \n          \n          contest_total_votes\n          People who voted in a specific race within the precinct.\n        \n\n      \n    \n\n    \n    \n      \n        \n          \n            Vote-for-N Contests\n            \n              \n              While most races restrict voters to a single vote per candidate (vote_for = 1), some races like City Council races allow voters to vote for multiple candidates (vote_for &gt; 1).\n              \n              When vote_for &gt; 1, contest_total_votes counts\n              selections, not ballots, contest_total_votes can exceed precinct_ballots_cast\n              and make rolloff_rate look negative.\n            \n          \n        \n      \n\n      \n        \n\n\n          \n          \n            max possible selections = precinct_ballots_cast × vote_for\n          \n\n          \n          \n            \n              precinct_ballots_cast 400\n            \n            \n              vote_for 2\n            \n            \n              contest_total_votes 650\n            \n          \n\n          \n          \n            Selections in this contest (scaled to max possible selections)\n            650 / 800\n          \n\n          \n            \n            \n          \n\n          \n            \n              \n              Selections counted (contest_total_votes)\n            \n            \n              \n              Unused selections (undervote)\n            \n          \n        \n      \n    \n    \n  \n\n  \n  \n\n    Data Dictionary\n\n\n    \n\n      \n      \n        \n          turnout_rate_precinct\n          How engaged is this neighborhood?\n        \n\n        \n          \n            \n              voter_turnout\n              voter_registration\n            \n          \n\n          =\n\n          \n            \n            0.45\n          \n        \n      \n\n      \n      \n        \n          choice_share\n          Percentage of the vote this candidate received.\n        \n\n        \n        \n          \n            \n              precinct_votes\n              contest_total_votes\n            \n          \n\n          =\n\n          \n            \n            \n              Candidate gets the blue slice.\n              Denominator is Sum of All Candidates.\n            \n          \n        \n      \n\n\n      \n      \n        \n          margin_votes\n          The vote gap between the top two candidates (Winner − Runner-up).\n        \n\n        \n        \n\n          \n          \n            winner_votes − runnerup_votes\n          \n\n          =\n\n          \n          \n            \n            \n              \n                Winner1,000\n              \n              \n                \n                \n              \n            \n\n            \n            \n              \n                Runner-up800\n              \n              \n                \n                \n              \n            \n          \n\n          \n          \n            \n              \n              \n              \n              \n              \n                \n                  margin_votes = 200\n                \n              \n            \n\n            \n              The red span shows the extra votes the winner has beyond the runner-up.\n            \n          \n        \n      \n\n      \n      \n        \n          rolloff_rate\n          Voters who ignored this specific race.\n        \n\n        \n        \n          \n            \n              ( precinct_ballots_cast - contest_total_votes )\n              precinct_ballots_cast\n            \n          \n\n          =\n\n          \n            Voted\n            Blank\n          \n        \n\n        \n          ⚠️ Negative Rolloff? In \"Vote for 2\" races, Total Votes &gt; Ballots Cast. Rolloff becomes negative. This is normal.\n        \n      \n\n      \n      \n        \n          polarization_fragmentation\n          Simpson Index: How split is the vote?\n        \n\n        \n        \n\n          \n            \n            \n              1 − Σ(\n              precinct_votes / contest_total_votes\n              )2\n            \n\n            =\n\n            \n            \n              \n              \n                0.1\n                \n                  \n                  \n                \n                Landslide\n              \n\n              \n              \n                0.8\n                \n                  \n                  \n                  \n                  \n                  \n                \n                Fractured\n              \n            \n\n            \n              Higher values mean votes are spread across more choices; lower values mean one choice dominates."
  },
  {
    "objectID": "blog/welcome.html",
    "href": "blog/welcome.html",
    "title": "Structure of the Democratic Party in Utah",
    "section": "",
    "text": "Elephant"
  },
  {
    "objectID": "data/sources.html",
    "href": "data/sources.html",
    "title": "Data Sources",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20251104_utah_county_municipal_general_election.json\nOriginal File Name: export-general11042025.json\n\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters\nFile Name: utah-county-ut_elections_general11042025_voters_body.html\n\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20250812_utah_county_municipal_primary_election.json\nOriginal File Name: export-primary08122025.json\n\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters\nFile Name: utah-county-ut_elections_primary08122025_voters_body.html\n\n\n\n\nThis CSV is the output of election_parsing.py:\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nimport numpy as np\nimport json\n\n###########\n\ndef parse_election_html(path, election_name):\n    soup = BeautifulSoup(Path(path).read_text(encoding=\"utf-8\"), \"html.parser\")\n\n    table = soup.select_one(\"table\")\n\n    def to_num(s: str):\n        s = re.sub(r\"[^0-9.-]\", \"\", re.sub(r\"[,\\u00A0]\", \"\", s.strip()))\n        return None if not s or s == \".\" else (float(s) if \".\" in s else int(s))\n\n    cols = [th.get_text(\" \", strip=True) for th in table.select(\"thead th\")][:4]\n\n    rows = []\n    for tr in table.select(\"tbody tr\"):\n        precinct = tr.find(\"th\", scope=\"row\").get_text(\" \", strip=True)\n\n        tds = tr.find_all(\"td\")[:3]\n        nums = [to_num(td.get_text(\" \", strip=True)) for td in tds]\n\n        rows.append([precinct, *nums])\n\n    df = pd\\\n        .DataFrame(\n            rows, \n            columns=[\"_\".join(c.lower().split()) for c in cols])\\\n        .assign(election_name = election_name)\\\n        .rename(columns={\n            \"precinct\": \"precinct_code\",\n            \"ballots_cast\": \"precinct_ballots_cast\",\n            \"registered_voters\": \"precinct_registered_voters\"})\n\n    return df\n\ndef parse_election_json(path, county=\"Utah County\"):\n\n    JSON = json.loads(Path(path).read_text(encoding=\"utf-8-sig\"))\n\n    def as_list(x):\n        return x if isinstance(x, list) else []\n\n    rows = []\n\n    for county in as_list(JSON.get(\"localResults\")):\n        if not isinstance(county, dict):\n            continue\n\n        county_id = county.get(\"id\")\n        county_name = county.get(\"name\")\n\n        for contest in as_list(county.get(\"ballotItems\")):\n            if not isinstance(contest, dict):\n                continue\n\n            contest_id = contest.get(\"id\")\n            contest_name = contest.get(\"name\")\n            contest_type = contest.get(\"type\")\n            contest_vote_for = contest.get(\"voteFor\")\n            contest_ballot_order = contest.get(\"ballotOrder\")\n\n            for opt in as_list(contest.get(\"ballotOptions\")):\n                if not isinstance(opt, dict):\n                    continue\n\n                opt_core = {\n                    \"election_date\": JSON.get(\"electionDate\"),\n                    \"election_name\": JSON.get(\"electionName\"),\n                    \"county_id\": county_id,\n                    \"county_name\": county_name,\n                    \"contest_id\": contest_id,\n                    \"contest_name\": contest_name,\n                    \"contest_type\": contest_type,\n                    \"contest_vote_for\": contest_vote_for,\n                    \"contest_ballot_order\": contest_ballot_order,\n                    \"choice_id\": opt.get(\"id\"),\n                    \"choice_name\": opt.get(\"name\"),\n                    \"choice_ballot_order\": opt.get(\"ballotOrder\"),\n                    \"choice_votes\": opt.get(\"voteCount\"),\n                    \"choice_party\": opt.get(\"politicalParty\") or None,\n                }\n\n                for pr in as_list(opt.get(\"precinctResults\")):\n                    if not isinstance(pr, dict):\n                        continue\n                    rows.append({**opt_core, **pr})\n\n    return pd\\\n        .DataFrame(rows)\\\n        .pipe(lambda df:\n            pd.json_normalize(df.to_dict(orient=\"records\"), sep=\".\"))\\\n        .rename({\n            \"name\": \"precinct_code\",\n            \"voteCount\": \"precinct_votes\"}, axis=1)\\\n        .filter(items=[\n            \"election_date\",\n            \"election_name\",\n            \"county_name\",\n            \"contest_name\",\n            \"contest_type\",\n            \"choice_name\",\n            \"precinct_code\",\n            \"precinct_votes\"])\n\ndef add_turnout_metrics(df):\n    return df\\\n    .assign(\n        is_zero_registration_precinct = pd.col(\"voter_registration\").eq(0),\n        is_zero_ballots_precinct = pd.col(\"precinct_ballots_cast\").eq(0),\n        turnout_rate_precinct = pd.col(\"voter_turnout\") / pd.col(\"voter_registration\"))\\\n    .assign(\n        turnout_rate_pct_precinct = pd.col(\"turnout_rate_precinct\").rank(pct=True, method=\"average\", na_option=\"keep\"))\n\ndef add_election_metrics(df):\n    return df\\\n        .assign(\n\n            # --- Contest vote distribution (per contest × precinct) ---\n            contest_total_votes=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"sum\"),\n\n            choice_share=(\n                (pd.col(\"precinct_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            choice_rank=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].rank(method=\"dense\", ascending=False),\n\n            polarization_fragmentation=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\n                    lambda s: (1 - np.square(s / s.sum()).sum()) if s.sum() &gt; 0 else np.nan)),\n\n            # --- Contest engagement (ballots that participated in the contest) ---\n            contest_participation_rate=(\n                (pd.col(\"contest_total_votes\") / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_count=(\n                (pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_rate=(\n                ((pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\")) / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n\n            # --- Outcome summary (winner / runner-up / margins) ---\n            winner_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"max\")\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n            runnerup_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"]\n                .transform(lambda s: (s.nlargest(2).iloc[1] if len(s) &gt; 1 else 0))\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n\n            margin_votes=(\n                (pd.col(\"winner_votes\") - pd.col(\"runnerup_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            margin_pct=(\n                (pd.col(\"margin_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            winner_share=(\n                (pd.col(\"winner_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            runnerup_share=(\n                (pd.col(\"runnerup_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            # --- Human-readable labels (ties become \"A | B\") ---\n            winner_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 1)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)),\n            runnerup_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 2)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)))\\\n        .sort_values(KEYS_PC + [\"precinct_votes\"], ascending=[True, True, True, True, False])\n\n###########\n\ndf_primary_json = parse_election_json(r\"20250812_utah_county_municipal_primary_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_general_json = parse_election_json(r\"20251104_utah_county_municipal_general_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_primary_totals = parse_election_html(r\"utah-county-ut_elections_primary08122025_voters_body.html\", \"2025 Utah Municipal Primary\")\\\n    .pipe(add_turnout_metrics)\n\ndf_general_totals = parse_election_html(r\"utah-county-ut_elections_general11042025_voters_body.html\", \"2025 Utah Municipal General Election\")\\\n    .pipe(add_turnout_metrics)\n\n\n###########\n\nKEYS_PC = [\"election_name\", \"county_name\", \"contest_name\", \"precinct_code\"]\n\ndf_general = df_general_json\\\n    .merge(\n        df_general_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n    \ndf_primary = df_primary_json\\\n    .merge(\n        df_primary_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n\n###########\n\nutah_county_elections = pd.concat([df_primary, df_general], ignore_index=True)\n\nutah_county_elections.to_csv(\"utah_county_elections.csv\", index=False)\n\n\nGrain: Each row represents one choice_name (candidate / YES / NO / etc.) within one contest_name within one precinct_code for a given election_name.\nBecause of that grain, precinct-wide totals (like registration, ballots cast) and contest-wide totals (like contest_total_votes) repeat across multiple rows (one per choice).\n\n\n\n\nelection_date (str)\nDate of the election in YYYY-MM-DD form (as provided by the source).\nExample: 2025-11-04.\nelection_name (str)\nHuman-readable election label (as provided by the source).\nExample: 2025 Utah Municipal General Election.\ncounty_name (str)\nCounty label (\"Utah County\" here).\n\n\n\n\n\ncontest_name (str)\nThe race/measure name as shown in results.\nExamples: \"Saratoga Springs Mayor\", \"School Board Lake Mountain 5\", \"Proposition #8 Eagle Mountain\".\ncontest_type (str)\nHigh-level contest category from the source (often \"Local\" in municipal datasets).\nchoice_name (str)\nThe selectable option within a contest (candidate name, \"YES\", \"NO\", write-in bucket, etc.).\n\n\n\n\n\nprecinct_code (str)\nPrecinct identifier used to join precinct-level results and turnout totals.\nExample: \"25SR15\".\n\n\n\n\n\nprecinct_votes (int)\nVotes recorded for this specific choice_name in this precinct for this contest.\n(This is the numerator for choice_share.)\nprecinct_ballots_cast (int)\nTotal ballots cast in the precinct for the election (precinct-wide).\nRepeats for all rows belonging to that precinct within the election.\nvoter_turnout (int)\nTurnout count for the precinct (precinct-wide).\nIn many exports this equals precinct_ballots_cast; if they differ, treat voter_turnout as the official turnout figure.\nvoter_registration (int)\nRegistered voters in the precinct (precinct-wide).\n\n\n\n\n\nis_zero_registration_precinct (bool)\nConvenience flag:\nvoter_registration == 0\nUseful to avoid divide-by-zero and to quickly locate placeholder/invalid precinct records.\nis_zero_ballots_precinct (bool)\nConvenience flag:\nprecinct_ballots_cast == 0\nUseful to identify precincts with no reported ballots or incomplete reporting.\n\n\n\n\n\nturnout_rate_precinct (float)\nTurnout fraction in the precinct:\nturnout_rate_precinct = voter_turnout / voter_registration\nTypically NaN (or undefined) if voter_registration == 0.\nturnout_rate_pct_precinct (float)\nPercent form of turnout:\nturnout_rate_pct_precinct = 100 * turnout_rate_precinct\n\n\n\n\n\ncontest_total_votes (int)\nTotal votes recorded in this contest in this precinct, across all choices:\ncontest_total_votes = Σ precinct_votes over all choice_name within the same\n(election_name, county_name, contest_name, precinct_code) group.\nInterpretation note: For multi-seat contests (e.g., “vote for up to 2”), contest_total_votes can be greater than precinct_ballots_cast.\nchoice_share (float)\nShare of the contest vote for this choice in this precinct:\nchoice_share = precinct_votes / contest_total_votes (when contest_total_votes &gt; 0).\nchoice_rank (float)\nRank of this choice by precinct_votes within the contest/precinct group (dense ranking, descending):\nchoice_rank = rank_dense_desc(precinct_votes within group)\n\n1 = top vote-getter(s)\n\nTies share the same rank\n\nNext rank increments by 1 (dense)\n\npolarization_fragmentation (float)\nA concentration/fragmentation index derived from vote shares (Simpson-style):\nLet p_i = precinct_votes_i / contest_total_votes for each choice in the group.\nThen:\npolarization_fragmentation = 1 - Σ(p_i^2) (when contest_total_votes &gt; 0)\nInterpretation:\n\nNear 0 → highly concentrated (one option dominates)\nLarger values → more fragmented (votes spread across options)\nMaximum depends on number of choices (more choices can raise the maximum)\n\n\n\n\n\nThese are computed using precinct_ballots_cast as a denominator.\n\ncontest_participation_rate (float)\nRate of ballots that recorded a vote in the contest (proxy):\ncontest_participation_rate = contest_total_votes / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nImportant interpretation note:\nThis behaves as expected for single-choice contests (mayor, proposition yes/no, etc.).\nFor multi-seat contests, contest_total_votes can exceed precinct_ballots_cast, so this can be &gt; 1 and should be interpreted as “votes per ballot” rather than “participation.”\nrolloff_count (float)\nBallots that did not record a vote in this contest (proxy):\nrolloff_count = precinct_ballots_cast - contest_total_votes (when precinct_ballots_cast &gt; 0)\nNote: Can be negative in multi-seat contests (because contest_total_votes may exceed ballots cast).\nIf you want a “never negative” roll-off for mapping, a common variant is:\nrolloff_count_clipped = max(rolloff_count, 0).\nrolloff_rate (float)\nRoll-off fraction:\nrolloff_rate = rolloff_count / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nSame caveat: may be negative for multi-seat contests.\n\n\n\n\nThese values repeat for every choice_name row inside the same contest/precinct group.\n\nwinner_votes (float)\nTop vote total in the contest/precinct group:\nwinner_votes = max(precinct_votes within group) (when contest_total_votes &gt; 0)\nrunnerup_votes (float)\nSecond-highest vote total in the group:\nrunnerup_votes = 2nd_largest(precinct_votes within group) (when contest_total_votes &gt; 0)\nEdge case:\n\nIf the contest has only one reported choice in the group, this may be set to 0 (or could be NaN depending on implementation preference).\n\nmargin_votes (float)\nVote margin between the top two choices:\nmargin_votes = winner_votes - runnerup_votes (when contest_total_votes &gt; 0)\nmargin_pct (float)\nMargin as a fraction of contest votes:\nmargin_pct = margin_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_share (float)\nWinner’s share of the contest vote:\nwinner_share = winner_votes / contest_total_votes (when contest_total_votes &gt; 0)\nrunnerup_share (float)\nRunner-up’s share of the contest vote:\nrunnerup_share = runnerup_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_choice_name (str)\nName(s) of the winning choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 1.\nIf there is a tie for first, names may be joined like: \"A | B\".\nrunnerup_choice_name (object / str; may contain NaN)\nName(s) of the 2nd-place choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 2.\nCan be NaN when there is no runner-up (e.g., uncontested contests or only one reported choice).\n\nNote: For multi-seat contests (like many “City Council” contests), you may observe: - contest_total_votes &gt; precinct_ballots_cast - therefore rolloff_count &lt; 0 and rolloff_rate &lt; 0\nThis does not necessarily indicate bad data; it usually means the contest allows selecting multiple candidates (so ballots can contribute multiple votes)."
  },
  {
    "objectID": "data/sources.html#utah-county-precinct-boundaries",
    "href": "data/sources.html#utah-county-precinct-boundaries",
    "title": "Data Sources",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson"
  },
  {
    "objectID": "data/sources.html#turnout-data",
    "href": "data/sources.html#turnout-data",
    "title": "Data Sources",
    "section": "",
    "text": "2025-11-04 Utah County Municipal General Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters * File Name: 20251104_utah_county_municipal_general_election.json * Original File Name: export-general11042025.json\n2025-08-12 Utah County Municipal Primary Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters * File Name: 20250812_utah_county_municipal_primary_election.json * Original File Name: export-primary08122025.json\n2024-11-05 Utah County General Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11052024/voters * File Name: 20241105_utah_county_general_election.json * Original File Name: export-general11052024.json\n2024-06-25 Utah County Primary Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary06252024/voters * File Name: 20240625_utah_county_primary_election.json * Original File Name: export-primary06252024.json\n2024-03-05 Utah County Presidential Preference Primary Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary03052024/voters * File Name: 20Original File Name: 240305_utah_county_presidential_preference_primary_election.json * export-primary03052024.json\n2023-11-21 Utah County General Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/2023-Nov-General/voters * File Name: 20231121_utah_county_general_election.json * Original File Name: export-2023-Nov-General.json"
  },
  {
    "objectID": "data/sources.html#utah-vista-ballot-areas-precinct-boundaries",
    "href": "data/sources.html#utah-vista-ballot-areas-precinct-boundaries",
    "title": "Data Sources",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson"
  },
  {
    "objectID": "data/sources.html#utah-county-municipal-general-election-json-data",
    "href": "data/sources.html#utah-county-municipal-general-election-json-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20251104_utah_county_municipal_general_election.json\nOriginal File Name: export-general11042025.json"
  },
  {
    "objectID": "data/sources.html#utah-municipal-general-election-voter-turnout-html-data",
    "href": "data/sources.html#utah-municipal-general-election-voter-turnout-html-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters\nFile Name: utah-county-ut_elections_general11042025_voters_body.html"
  },
  {
    "objectID": "data/sources.html#utah-county-municipal-primary-json-data",
    "href": "data/sources.html#utah-county-municipal-primary-json-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20250812_utah_county_municipal_primary_election.json\nOriginal File Name: export-primary08122025.json"
  },
  {
    "objectID": "data/sources.html#utah-municipal-primary-voter-turnout-html-data",
    "href": "data/sources.html#utah-municipal-primary-voter-turnout-html-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters\nFile Name: utah-county-ut_elections_primary08122025_voters_body.html"
  },
  {
    "objectID": "data/sources.html#utah_county_elections.csv",
    "href": "data/sources.html#utah_county_elections.csv",
    "title": "Data Sources",
    "section": "",
    "text": "This CSV is the output of election_parsing.py:\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nimport numpy as np\nimport json\n\n###########\n\ndef parse_election_html(path, election_name):\n    soup = BeautifulSoup(Path(path).read_text(encoding=\"utf-8\"), \"html.parser\")\n\n    table = soup.select_one(\"table\")\n\n    def to_num(s: str):\n        s = re.sub(r\"[^0-9.-]\", \"\", re.sub(r\"[,\\u00A0]\", \"\", s.strip()))\n        return None if not s or s == \".\" else (float(s) if \".\" in s else int(s))\n\n    cols = [th.get_text(\" \", strip=True) for th in table.select(\"thead th\")][:4]\n\n    rows = []\n    for tr in table.select(\"tbody tr\"):\n        precinct = tr.find(\"th\", scope=\"row\").get_text(\" \", strip=True)\n\n        tds = tr.find_all(\"td\")[:3]\n        nums = [to_num(td.get_text(\" \", strip=True)) for td in tds]\n\n        rows.append([precinct, *nums])\n\n    df = pd\\\n        .DataFrame(\n            rows, \n            columns=[\"_\".join(c.lower().split()) for c in cols])\\\n        .assign(election_name = election_name)\\\n        .rename(columns={\n            \"precinct\": \"precinct_code\",\n            \"ballots_cast\": \"precinct_ballots_cast\",\n            \"registered_voters\": \"precinct_registered_voters\"})\n\n    return df\n\ndef parse_election_json(path, county=\"Utah County\"):\n\n    JSON = json.loads(Path(path).read_text(encoding=\"utf-8-sig\"))\n\n    def as_list(x):\n        return x if isinstance(x, list) else []\n\n    rows = []\n\n    for county in as_list(JSON.get(\"localResults\")):\n        if not isinstance(county, dict):\n            continue\n\n        county_id = county.get(\"id\")\n        county_name = county.get(\"name\")\n\n        for contest in as_list(county.get(\"ballotItems\")):\n            if not isinstance(contest, dict):\n                continue\n\n            contest_id = contest.get(\"id\")\n            contest_name = contest.get(\"name\")\n            contest_type = contest.get(\"type\")\n            contest_vote_for = contest.get(\"voteFor\")\n            contest_ballot_order = contest.get(\"ballotOrder\")\n\n            for opt in as_list(contest.get(\"ballotOptions\")):\n                if not isinstance(opt, dict):\n                    continue\n\n                opt_core = {\n                    \"election_date\": JSON.get(\"electionDate\"),\n                    \"election_name\": JSON.get(\"electionName\"),\n                    \"county_id\": county_id,\n                    \"county_name\": county_name,\n                    \"contest_id\": contest_id,\n                    \"contest_name\": contest_name,\n                    \"contest_type\": contest_type,\n                    \"contest_vote_for\": contest_vote_for,\n                    \"contest_ballot_order\": contest_ballot_order,\n                    \"choice_id\": opt.get(\"id\"),\n                    \"choice_name\": opt.get(\"name\"),\n                    \"choice_ballot_order\": opt.get(\"ballotOrder\"),\n                    \"choice_votes\": opt.get(\"voteCount\"),\n                    \"choice_party\": opt.get(\"politicalParty\") or None,\n                }\n\n                for pr in as_list(opt.get(\"precinctResults\")):\n                    if not isinstance(pr, dict):\n                        continue\n                    rows.append({**opt_core, **pr})\n\n    return pd\\\n        .DataFrame(rows)\\\n        .pipe(lambda df:\n            pd.json_normalize(df.to_dict(orient=\"records\"), sep=\".\"))\\\n        .rename({\n            \"name\": \"precinct_code\",\n            \"voteCount\": \"precinct_votes\"}, axis=1)\\\n        .filter(items=[\n            \"election_date\",\n            \"election_name\",\n            \"county_name\",\n            \"contest_name\",\n            \"contest_type\",\n            \"choice_name\",\n            \"precinct_code\",\n            \"precinct_votes\"])\n\ndef add_turnout_metrics(df):\n    return df\\\n    .assign(\n        is_zero_registration_precinct = pd.col(\"voter_registration\").eq(0),\n        is_zero_ballots_precinct = pd.col(\"precinct_ballots_cast\").eq(0),\n        turnout_rate_precinct = pd.col(\"voter_turnout\") / pd.col(\"voter_registration\"))\\\n    .assign(\n        turnout_rate_pct_precinct = pd.col(\"turnout_rate_precinct\").rank(pct=True, method=\"average\", na_option=\"keep\"))\n\ndef add_election_metrics(df):\n    return df\\\n        .assign(\n\n            # --- Contest vote distribution (per contest × precinct) ---\n            contest_total_votes=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"sum\"),\n\n            choice_share=(\n                (pd.col(\"precinct_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            choice_rank=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].rank(method=\"dense\", ascending=False),\n\n            polarization_fragmentation=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\n                    lambda s: (1 - np.square(s / s.sum()).sum()) if s.sum() &gt; 0 else np.nan)),\n\n            # --- Contest engagement (ballots that participated in the contest) ---\n            contest_participation_rate=(\n                (pd.col(\"contest_total_votes\") / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_count=(\n                (pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_rate=(\n                ((pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\")) / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n\n            # --- Outcome summary (winner / runner-up / margins) ---\n            winner_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"max\")\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n            runnerup_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"]\n                .transform(lambda s: (s.nlargest(2).iloc[1] if len(s) &gt; 1 else 0))\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n\n            margin_votes=(\n                (pd.col(\"winner_votes\") - pd.col(\"runnerup_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            margin_pct=(\n                (pd.col(\"margin_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            winner_share=(\n                (pd.col(\"winner_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            runnerup_share=(\n                (pd.col(\"runnerup_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            # --- Human-readable labels (ties become \"A | B\") ---\n            winner_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 1)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)),\n            runnerup_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 2)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)))\\\n        .sort_values(KEYS_PC + [\"precinct_votes\"], ascending=[True, True, True, True, False])\n\n###########\n\ndf_primary_json = parse_election_json(r\"20250812_utah_county_municipal_primary_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_general_json = parse_election_json(r\"20251104_utah_county_municipal_general_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_primary_totals = parse_election_html(r\"utah-county-ut_elections_primary08122025_voters_body.html\", \"2025 Utah Municipal Primary\")\\\n    .pipe(add_turnout_metrics)\n\ndf_general_totals = parse_election_html(r\"utah-county-ut_elections_general11042025_voters_body.html\", \"2025 Utah Municipal General Election\")\\\n    .pipe(add_turnout_metrics)\n\n\n###########\n\nKEYS_PC = [\"election_name\", \"county_name\", \"contest_name\", \"precinct_code\"]\n\ndf_general = df_general_json\\\n    .merge(\n        df_general_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n    \ndf_primary = df_primary_json\\\n    .merge(\n        df_primary_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n\n###########\n\nutah_county_elections = pd.concat([df_primary, df_general], ignore_index=True)\n\nutah_county_elections.to_csv(\"utah_county_elections.csv\", index=False)\n\n\nGrain: Each row represents one choice_name (candidate / YES / NO / etc.) within one contest_name within one precinct_code for a given election_name.\nBecause of that grain, precinct-wide totals (like registration, ballots cast) and contest-wide totals (like contest_total_votes) repeat across multiple rows (one per choice).\n\n\n\n\nelection_date (str)\nDate of the election in YYYY-MM-DD form (as provided by the source).\nExample: 2025-11-04.\nelection_name (str)\nHuman-readable election label (as provided by the source).\nExample: 2025 Utah Municipal General Election.\ncounty_name (str)\nCounty label (\"Utah County\" here).\n\n\n\n\n\ncontest_name (str)\nThe race/measure name as shown in results.\nExamples: \"Saratoga Springs Mayor\", \"School Board Lake Mountain 5\", \"Proposition #8 Eagle Mountain\".\ncontest_type (str)\nHigh-level contest category from the source (often \"Local\" in municipal datasets).\nchoice_name (str)\nThe selectable option within a contest (candidate name, \"YES\", \"NO\", write-in bucket, etc.).\n\n\n\n\n\nprecinct_code (str)\nPrecinct identifier used to join precinct-level results and turnout totals.\nExample: \"25SR15\".\n\n\n\n\n\nprecinct_votes (int)\nVotes recorded for this specific choice_name in this precinct for this contest.\n(This is the numerator for choice_share.)\nprecinct_ballots_cast (int)\nTotal ballots cast in the precinct for the election (precinct-wide).\nRepeats for all rows belonging to that precinct within the election.\nvoter_turnout (int)\nTurnout count for the precinct (precinct-wide).\nIn many exports this equals precinct_ballots_cast; if they differ, treat voter_turnout as the official turnout figure.\nvoter_registration (int)\nRegistered voters in the precinct (precinct-wide).\n\n\n\n\n\nis_zero_registration_precinct (bool)\nConvenience flag:\nvoter_registration == 0\nUseful to avoid divide-by-zero and to quickly locate placeholder/invalid precinct records.\nis_zero_ballots_precinct (bool)\nConvenience flag:\nprecinct_ballots_cast == 0\nUseful to identify precincts with no reported ballots or incomplete reporting.\n\n\n\n\n\nturnout_rate_precinct (float)\nTurnout fraction in the precinct:\nturnout_rate_precinct = voter_turnout / voter_registration\nTypically NaN (or undefined) if voter_registration == 0.\nturnout_rate_pct_precinct (float)\nPercent form of turnout:\nturnout_rate_pct_precinct = 100 * turnout_rate_precinct\n\n\n\n\n\ncontest_total_votes (int)\nTotal votes recorded in this contest in this precinct, across all choices:\ncontest_total_votes = Σ precinct_votes over all choice_name within the same\n(election_name, county_name, contest_name, precinct_code) group.\nInterpretation note: For multi-seat contests (e.g., “vote for up to 2”), contest_total_votes can be greater than precinct_ballots_cast.\nchoice_share (float)\nShare of the contest vote for this choice in this precinct:\nchoice_share = precinct_votes / contest_total_votes (when contest_total_votes &gt; 0).\nchoice_rank (float)\nRank of this choice by precinct_votes within the contest/precinct group (dense ranking, descending):\nchoice_rank = rank_dense_desc(precinct_votes within group)\n\n1 = top vote-getter(s)\n\nTies share the same rank\n\nNext rank increments by 1 (dense)\n\npolarization_fragmentation (float)\nA concentration/fragmentation index derived from vote shares (Simpson-style):\nLet p_i = precinct_votes_i / contest_total_votes for each choice in the group.\nThen:\npolarization_fragmentation = 1 - Σ(p_i^2) (when contest_total_votes &gt; 0)\nInterpretation:\n\nNear 0 → highly concentrated (one option dominates)\nLarger values → more fragmented (votes spread across options)\nMaximum depends on number of choices (more choices can raise the maximum)\n\n\n\n\n\nThese are computed using precinct_ballots_cast as a denominator.\n\ncontest_participation_rate (float)\nRate of ballots that recorded a vote in the contest (proxy):\ncontest_participation_rate = contest_total_votes / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nImportant interpretation note:\nThis behaves as expected for single-choice contests (mayor, proposition yes/no, etc.).\nFor multi-seat contests, contest_total_votes can exceed precinct_ballots_cast, so this can be &gt; 1 and should be interpreted as “votes per ballot” rather than “participation.”\nrolloff_count (float)\nBallots that did not record a vote in this contest (proxy):\nrolloff_count = precinct_ballots_cast - contest_total_votes (when precinct_ballots_cast &gt; 0)\nNote: Can be negative in multi-seat contests (because contest_total_votes may exceed ballots cast).\nIf you want a “never negative” roll-off for mapping, a common variant is:\nrolloff_count_clipped = max(rolloff_count, 0).\nrolloff_rate (float)\nRoll-off fraction:\nrolloff_rate = rolloff_count / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nSame caveat: may be negative for multi-seat contests.\n\n\n\n\nThese values repeat for every choice_name row inside the same contest/precinct group.\n\nwinner_votes (float)\nTop vote total in the contest/precinct group:\nwinner_votes = max(precinct_votes within group) (when contest_total_votes &gt; 0)\nrunnerup_votes (float)\nSecond-highest vote total in the group:\nrunnerup_votes = 2nd_largest(precinct_votes within group) (when contest_total_votes &gt; 0)\nEdge case:\n\nIf the contest has only one reported choice in the group, this may be set to 0 (or could be NaN depending on implementation preference).\n\nmargin_votes (float)\nVote margin between the top two choices:\nmargin_votes = winner_votes - runnerup_votes (when contest_total_votes &gt; 0)\nmargin_pct (float)\nMargin as a fraction of contest votes:\nmargin_pct = margin_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_share (float)\nWinner’s share of the contest vote:\nwinner_share = winner_votes / contest_total_votes (when contest_total_votes &gt; 0)\nrunnerup_share (float)\nRunner-up’s share of the contest vote:\nrunnerup_share = runnerup_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_choice_name (str)\nName(s) of the winning choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 1.\nIf there is a tie for first, names may be joined like: \"A | B\".\nrunnerup_choice_name (object / str; may contain NaN)\nName(s) of the 2nd-place choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 2.\nCan be NaN when there is no runner-up (e.g., uncontested contests or only one reported choice).\n\nNote: For multi-seat contests (like many “City Council” contests), you may observe: - contest_total_votes &gt; precinct_ballots_cast - therefore rolloff_count &lt; 0 and rolloff_rate &lt; 0\nThis does not necessarily indicate bad data; it usually means the contest allows selecting multiple candidates (so ballots can contribute multiple votes)."
  },
  {
    "objectID": "blog/metric.html#utah-vista-ballot-areas-precinct-boundaries",
    "href": "blog/metric.html#utah-vista-ballot-areas-precinct-boundaries",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson"
  },
  {
    "objectID": "blog/metric.html#utah-county-municipal-general-election-json-data",
    "href": "blog/metric.html#utah-county-municipal-general-election-json-data",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20251104_utah_county_municipal_general_election.json\nOriginal File Name: export-general11042025.json"
  },
  {
    "objectID": "blog/metric.html#utah-municipal-general-election-voter-turnout-html-data",
    "href": "blog/metric.html#utah-municipal-general-election-voter-turnout-html-data",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters\nFile Name: utah-county-ut_elections_general11042025_voters_body.html"
  },
  {
    "objectID": "blog/metric.html#utah-county-municipal-primary-json-data",
    "href": "blog/metric.html#utah-county-municipal-primary-json-data",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20250812_utah_county_municipal_primary_election.json\nOriginal File Name: export-primary08122025.json"
  },
  {
    "objectID": "blog/metric.html#utah-municipal-primary-voter-turnout-html-data",
    "href": "blog/metric.html#utah-municipal-primary-voter-turnout-html-data",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters\nFile Name: utah-county-ut_elections_primary08122025_voters_body.html"
  },
  {
    "objectID": "blog/metric.html#utah_county_elections.csv",
    "href": "blog/metric.html#utah_county_elections.csv",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "This CSV is the output of election_parsing.py:\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nimport numpy as np\nimport json\n\n###########\n\ndef parse_election_html(path, election_name):\n    soup = BeautifulSoup(Path(path).read_text(encoding=\"utf-8\"), \"html.parser\")\n\n    table = soup.select_one(\"table\")\n\n    def to_num(s: str):\n        s = re.sub(r\"[^0-9.-]\", \"\", re.sub(r\"[,\\u00A0]\", \"\", s.strip()))\n        return None if not s or s == \".\" else (float(s) if \".\" in s else int(s))\n\n    cols = [th.get_text(\" \", strip=True) for th in table.select(\"thead th\")][:4]\n\n    rows = []\n    for tr in table.select(\"tbody tr\"):\n        precinct = tr.find(\"th\", scope=\"row\").get_text(\" \", strip=True)\n\n        tds = tr.find_all(\"td\")[:3]\n        nums = [to_num(td.get_text(\" \", strip=True)) for td in tds]\n\n        rows.append([precinct, *nums])\n\n    df = pd\\\n        .DataFrame(\n            rows, \n            columns=[\"_\".join(c.lower().split()) for c in cols])\\\n        .assign(election_name = election_name)\\\n        .rename(columns={\n            \"precinct\": \"precinct_code\",\n            \"ballots_cast\": \"precinct_ballots_cast\",\n            \"registered_voters\": \"precinct_registered_voters\"})\n\n    return df\n\ndef parse_election_json(path, county=\"Utah County\"):\n\n    JSON = json.loads(Path(path).read_text(encoding=\"utf-8-sig\"))\n\n    def as_list(x):\n        return x if isinstance(x, list) else []\n\n    rows = []\n\n    for county in as_list(JSON.get(\"localResults\")):\n        if not isinstance(county, dict):\n            continue\n\n        county_id = county.get(\"id\")\n        county_name = county.get(\"name\")\n\n        for contest in as_list(county.get(\"ballotItems\")):\n            if not isinstance(contest, dict):\n                continue\n\n            contest_id = contest.get(\"id\")\n            contest_name = contest.get(\"name\")\n            contest_type = contest.get(\"type\")\n            contest_vote_for = contest.get(\"voteFor\")\n            contest_ballot_order = contest.get(\"ballotOrder\")\n\n            for opt in as_list(contest.get(\"ballotOptions\")):\n                if not isinstance(opt, dict):\n                    continue\n\n                opt_core = {\n                    \"election_date\": JSON.get(\"electionDate\"),\n                    \"election_name\": JSON.get(\"electionName\"),\n                    \"county_id\": county_id,\n                    \"county_name\": county_name,\n                    \"contest_id\": contest_id,\n                    \"contest_name\": contest_name,\n                    \"contest_type\": contest_type,\n                    \"contest_vote_for\": contest_vote_for,\n                    \"contest_ballot_order\": contest_ballot_order,\n                    \"choice_id\": opt.get(\"id\"),\n                    \"choice_name\": opt.get(\"name\"),\n                    \"choice_ballot_order\": opt.get(\"ballotOrder\"),\n                    \"choice_votes\": opt.get(\"voteCount\"),\n                    \"choice_party\": opt.get(\"politicalParty\") or None,\n                }\n\n                for pr in as_list(opt.get(\"precinctResults\")):\n                    if not isinstance(pr, dict):\n                        continue\n                    rows.append({**opt_core, **pr})\n\n    return pd\\\n        .DataFrame(rows)\\\n        .pipe(lambda df:\n            pd.json_normalize(df.to_dict(orient=\"records\"), sep=\".\"))\\\n        .rename({\n            \"name\": \"precinct_code\",\n            \"voteCount\": \"precinct_votes\"}, axis=1)\\\n        .filter(items=[\n            \"election_date\",\n            \"election_name\",\n            \"county_name\",\n            \"contest_name\",\n            \"contest_type\",\n            \"choice_name\",\n            \"precinct_code\",\n            \"precinct_votes\"])\n\ndef add_turnout_metrics(df):\n    return df\\\n    .assign(\n        is_zero_registration_precinct = pd.col(\"voter_registration\").eq(0),\n        is_zero_ballots_precinct = pd.col(\"precinct_ballots_cast\").eq(0),\n        turnout_rate_precinct = pd.col(\"voter_turnout\") / pd.col(\"voter_registration\"))\\\n    .assign(\n        turnout_rate_pct_precinct = pd.col(\"turnout_rate_precinct\").rank(pct=True, method=\"average\", na_option=\"keep\"))\n\ndef add_election_metrics(df):\n    return df\\\n        .assign(\n\n            # --- Contest vote distribution (per contest × precinct) ---\n            contest_total_votes=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"sum\"),\n\n            choice_share=(\n                (pd.col(\"precinct_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            choice_rank=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].rank(method=\"dense\", ascending=False),\n\n            polarization_fragmentation=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\n                    lambda s: (1 - np.square(s / s.sum()).sum()) if s.sum() &gt; 0 else np.nan)),\n\n            # --- Contest engagement (ballots that participated in the contest) ---\n            contest_participation_rate=(\n                (pd.col(\"contest_total_votes\") / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_count=(\n                (pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_rate=(\n                ((pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\")) / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n\n            # --- Outcome summary (winner / runner-up / margins) ---\n            winner_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"max\")\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n            runnerup_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"]\n                .transform(lambda s: (s.nlargest(2).iloc[1] if len(s) &gt; 1 else 0))\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n\n            margin_votes=(\n                (pd.col(\"winner_votes\") - pd.col(\"runnerup_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            margin_pct=(\n                (pd.col(\"margin_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            winner_share=(\n                (pd.col(\"winner_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            runnerup_share=(\n                (pd.col(\"runnerup_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            # --- Human-readable labels (ties become \"A | B\") ---\n            winner_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 1)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)),\n            runnerup_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 2)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)))\\\n        .sort_values(KEYS_PC + [\"precinct_votes\"], ascending=[True, True, True, True, False])\n\n###########\n\ndf_primary_json = parse_election_json(r\"20250812_utah_county_municipal_primary_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_general_json = parse_election_json(r\"20251104_utah_county_municipal_general_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_primary_totals = parse_election_html(r\"utah-county-ut_elections_primary08122025_voters_body.html\", \"2025 Utah Municipal Primary\")\\\n    .pipe(add_turnout_metrics)\n\ndf_general_totals = parse_election_html(r\"utah-county-ut_elections_general11042025_voters_body.html\", \"2025 Utah Municipal General Election\")\\\n    .pipe(add_turnout_metrics)\n\n\n###########\n\nKEYS_PC = [\"election_name\", \"county_name\", \"contest_name\", \"precinct_code\"]\n\ndf_general = df_general_json\\\n    .merge(\n        df_general_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n    \ndf_primary = df_primary_json\\\n    .merge(\n        df_primary_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n\n###########\n\nutah_county_elections = pd.concat([df_primary, df_general], ignore_index=True)\n\nutah_county_elections.to_csv(\"utah_county_elections.csv\", index=False)\n\n\nGrain: Each row represents one choice_name (candidate / YES / NO / etc.) within one contest_name within one precinct_code for a given election_name.\nBecause of that grain, precinct-wide totals (like registration, ballots cast) and contest-wide totals (like contest_total_votes) repeat across multiple rows (one per choice).\n\n\n\n\nelection_date (str)\nDate of the election in YYYY-MM-DD form (as provided by the source).\nExample: 2025-11-04.\nelection_name (str)\nHuman-readable election label (as provided by the source).\nExample: 2025 Utah Municipal General Election.\ncounty_name (str)\nCounty label (\"Utah County\" here).\n\n\n\n\n\ncontest_name (str)\nThe race/measure name as shown in results.\nExamples: \"Saratoga Springs Mayor\", \"School Board Lake Mountain 5\", \"Proposition #8 Eagle Mountain\".\ncontest_type (str)\nHigh-level contest category from the source (often \"Local\" in municipal datasets).\nchoice_name (str)\nThe selectable option within a contest (candidate name, \"YES\", \"NO\", write-in bucket, etc.).\n\n\n\n\n\nprecinct_code (str)\nPrecinct identifier used to join precinct-level results and turnout totals.\nExample: \"25SR15\".\n\n\n\n\n\nprecinct_votes (int)\nVotes recorded for this specific choice_name in this precinct for this contest.\n(This is the numerator for choice_share.)\nprecinct_ballots_cast (int)\nTotal ballots cast in the precinct for the election (precinct-wide).\nRepeats for all rows belonging to that precinct within the election.\nvoter_turnout (int)\nTurnout count for the precinct (precinct-wide).\nIn many exports this equals precinct_ballots_cast; if they differ, treat voter_turnout as the official turnout figure.\nvoter_registration (int)\nRegistered voters in the precinct (precinct-wide).\n\n\n\n\n\nis_zero_registration_precinct (bool)\nConvenience flag:\nvoter_registration == 0\nUseful to avoid divide-by-zero and to quickly locate placeholder/invalid precinct records.\nis_zero_ballots_precinct (bool)\nConvenience flag:\nprecinct_ballots_cast == 0\nUseful to identify precincts with no reported ballots or incomplete reporting.\n\n\n\n\n\nturnout_rate_precinct (float)\nTurnout fraction in the precinct:\nturnout_rate_precinct = voter_turnout / voter_registration\nTypically NaN (or undefined) if voter_registration == 0.\nturnout_rate_pct_precinct (float)\nPercent form of turnout:\nturnout_rate_pct_precinct = 100 * turnout_rate_precinct\n\n\n\n\n\ncontest_total_votes (int)\nTotal votes recorded in this contest in this precinct, across all choices:\ncontest_total_votes = Σ precinct_votes over all choice_name within the same\n(election_name, county_name, contest_name, precinct_code) group.\nInterpretation note: For multi-seat contests (e.g., “vote for up to 2”), contest_total_votes can be greater than precinct_ballots_cast.\nchoice_share (float)\nShare of the contest vote for this choice in this precinct:\nchoice_share = precinct_votes / contest_total_votes (when contest_total_votes &gt; 0).\nchoice_rank (float)\nRank of this choice by precinct_votes within the contest/precinct group (dense ranking, descending):\nchoice_rank = rank_dense_desc(precinct_votes within group)\n\n1 = top vote-getter(s)\n\nTies share the same rank\n\nNext rank increments by 1 (dense)\n\npolarization_fragmentation (float)\nA concentration/fragmentation index derived from vote shares (Simpson-style):\nLet p_i = precinct_votes_i / contest_total_votes for each choice in the group.\nThen:\npolarization_fragmentation = 1 - Σ(p_i^2) (when contest_total_votes &gt; 0)\nInterpretation:\n\nNear 0 → highly concentrated (one option dominates)\nLarger values → more fragmented (votes spread across options)\nMaximum depends on number of choices (more choices can raise the maximum)\n\n\n\n\n\nThese are computed using precinct_ballots_cast as a denominator.\n\ncontest_participation_rate (float)\nRate of ballots that recorded a vote in the contest (proxy):\ncontest_participation_rate = contest_total_votes / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nImportant interpretation note:\nThis behaves as expected for single-choice contests (mayor, proposition yes/no, etc.).\nFor multi-seat contests, contest_total_votes can exceed precinct_ballots_cast, so this can be &gt; 1 and should be interpreted as “votes per ballot” rather than “participation.”\nrolloff_count (float)\nBallots that did not record a vote in this contest (proxy):\nrolloff_count = precinct_ballots_cast - contest_total_votes (when precinct_ballots_cast &gt; 0)\nNote: Can be negative in multi-seat contests (because contest_total_votes may exceed ballots cast).\nIf you want a “never negative” roll-off for mapping, a common variant is:\nrolloff_count_clipped = max(rolloff_count, 0).\nrolloff_rate (float)\nRoll-off fraction:\nrolloff_rate = rolloff_count / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nSame caveat: may be negative for multi-seat contests.\n\n\n\n\nThese values repeat for every choice_name row inside the same contest/precinct group.\n\nwinner_votes (float)\nTop vote total in the contest/precinct group:\nwinner_votes = max(precinct_votes within group) (when contest_total_votes &gt; 0)\nrunnerup_votes (float)\nSecond-highest vote total in the group:\nrunnerup_votes = 2nd_largest(precinct_votes within group) (when contest_total_votes &gt; 0)\nEdge case:\n\nIf the contest has only one reported choice in the group, this may be set to 0 (or could be NaN depending on implementation preference).\n\nmargin_votes (float)\nVote margin between the top two choices:\nmargin_votes = winner_votes - runnerup_votes (when contest_total_votes &gt; 0)\nmargin_pct (float)\nMargin as a fraction of contest votes:\nmargin_pct = margin_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_share (float)\nWinner’s share of the contest vote:\nwinner_share = winner_votes / contest_total_votes (when contest_total_votes &gt; 0)\nrunnerup_share (float)\nRunner-up’s share of the contest vote:\nrunnerup_share = runnerup_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_choice_name (str)\nName(s) of the winning choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 1.\nIf there is a tie for first, names may be joined like: \"A | B\".\nrunnerup_choice_name (object / str; may contain NaN)\nName(s) of the 2nd-place choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 2.\nCan be NaN when there is no runner-up (e.g., uncontested contests or only one reported choice).\n\nNote: For multi-seat contests (like many “City Council” contests), you may observe: - contest_total_votes &gt; precinct_ballots_cast - therefore rolloff_count &lt; 0 and rolloff_rate &lt; 0\nThis does not necessarily indicate bad data; it usually means the contest allows selecting multiple candidates (so ballots can contribute multiple votes)."
  },
  {
    "objectID": "blog/metric.html#part-1-the-raw-ingredients",
    "href": "blog/metric.html#part-1-the-raw-ingredients",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "We didn’t just scrape one website. To get a complete picture of who voted and where, we had to merge three distinct datasets.\n\n\n\nSource: Utah’s Open Data Portal (VISTA Ballot Areas)\nWhat it is: This provides the actual shapes (polygons) of the voting precincts.\nProcessing: We filtered the statewide map down to Utah County (ID 25), cleaned up the coordinates for web mapping, and simplified the shapes slightly so they load faster in your browser.\n\n\n\n\n\nSource: Utah Election Night Reporting (Media Export)\nWhat it is: A granular JSON file containing the raw vote counts for every candidate in every race.\nWhy we use it: This is the most detailed source available. It tells us exactly how many votes Candidate X got in Precinct Y.\n\n\n\n\n\nSource: Utah Election Night Reporting (Voter Turnout Tab)\nWhat it is: An HTML table scraped from the “Voter Turnout” page.\nThe Missing Piece: The JSON results file tells us how many people voted for a candidate, but it doesn’t tell us how many registered voters live in that precinct. This HTML file fills that gap, giving us Registered Voters and Ballots Cast per precinct."
  },
  {
    "objectID": "blog/metric.html#part-2-the-grain-of-the-data",
    "href": "blog/metric.html#part-2-the-grain-of-the-data",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Before you dive into the columns, you must understand the grain of the CSV file.\nOne Row = One Candidate, in One Contest, in One Precinct.\n\nIf there are 3 candidates running for Mayor in Saratoga Springs, and there are 10 precincts, that single race will generate 30 rows of data.\nImportant Note: Because the data is broken down by candidate, precinct-wide totals (like Registered Voters or Ballots Cast) will repeat on multiple rows. If you sum up the Registered Voters column for the whole file, you will get a massively inflated number. Always group by precinct before summing these totals."
  },
  {
    "objectID": "blog/metric.html#part-3-the-dictionary-column-guide",
    "href": "blog/metric.html#part-3-the-dictionary-column-guide",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "Here is how to read the data, split into “Basic” columns (raw facts) and “Calculated” columns (metrics we derived for analysis).\n\n\n\nprecinct_votes: The actual number of votes the specific candidate (row) received.\nprecinct_ballots_cast: The total number of people who physically cast a ballot in this precinct.\nvoter_registration: The total number of people allowed to vote in this precinct.\n\n\n\n\nWe added several metrics to help you spot trends instantly without doing your own math.\n\n\n\nturnout_rate_precinct:\n\nFormula: voter_turnout / voter_registration\nMeaning: The percentage of registered voters who actually voted. High numbers indicate an engaged electorate; low numbers indicate apathy.\n\n\n\n\n\n\nchoice_share:\n\nFormula: precinct_votes / contest_total_votes\nMeaning: The candidate’s slice of the pie. If this is 0.60, they got 60% of the vote in that precinct.\n\nmargin_pct:\n\nMeaning: The gap between the winner and the runner-up.\nUsage: Use this to find “battleground” precincts. A margin of 0.01 (1%) means it was a nail-biter; a margin of 0.50 (50%) was a landslide.\n\n\n\n\n\n\nrolloff_rate:\n\nFormula: (precinct_ballots_cast - contest_total_votes) / precinct_ballots_cast\nMeaning: This measures “voter fatigue.” It represents the percentage of people who cast a ballot but left this specific race blank.\nUsage: High rolloff often happens in “down-ballot” races (like judges or local props) that voters don’t know much about.\n⚠️ The Multi-Seat Anomaly: In races where you can “Vote for 2” (like City Council), the total votes might exceed the number of ballots cast. In these cases, the rolloff_rate will be negative. This isn’t a bug—it just means people used their multiple votes enthusiastically!\n\n\n\n\n\n\npolarization_fragmentation:\n\nThe Math: We use a variation of the Simpson Index (\\(1 - \\sum p_i^2\\)).\nMeaning: This number (0 to 1) tells you how “fractured” the vote was.\n\nNear 0: Everyone voted for the same person (highly concentrated).\nHigh Value: Votes were scattered evenly across many candidates (highly fragmented).\n\nUsage: Useful for primaries. A high fragmentation score suggests the electorate is undecided or the field is crowded with similar candidates.\n\n\n\n\n\n\nwinner_choice_name: The name of the person who won this specific precinct.\nrunnerup_choice_name: The name of the person who came in second.\nUsage: Essential for “Winner Maps.” You can color-code a map based on this column to see which candidate “owned” which neighborhoods."
  },
  {
    "objectID": "blog/metric.html#practical-examples-what-can-you-do-with-this",
    "href": "blog/metric.html#practical-examples-what-can-you-do-with-this",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "1. Spotting the “Enthusiasm Gap” Map the turnout_rate_precinct. You will likely see that newer developments or transient areas have lower turnout than established, older neighborhoods.\n2. Finding the “Hidden” Winner Sometimes a candidate loses the overall election but wins specific neighborhoods. Filter for choice_rank == 1 and map the winner_choice_name to see pockets of local support that might be invisible in the top-line results.\n3. The “Undefined” Voter Look for precincts with a high rolloff_rate (positive values only). These are areas where people showed up to vote for Mayor but skipped the School Board race. This identifies a lack of information or engagement with that specific topic."
  }
]