[
  {
    "objectID": "blog/metric.html",
    "href": "blog/metric.html",
    "title": "Quick Metric: Contact → Show Rate",
    "section": "",
    "text": "A simple weekly check: how many scheduled voters actually show up (events, canvass shifts, trainings).\nIf the show rate drops, try: - confirm the day before - send a map + time estimate - offer a buddy option (bring a friend)"
  },
  {
    "objectID": "blog/welcome.html",
    "href": "blog/welcome.html",
    "title": "Welcome: What This Blog Is For",
    "section": "",
    "text": "This is a lightweight place to share Utah County–specific political data and practical strategy.\n\nKeep posts short\nLink sources when you can\nEnd with one clear takeaway"
  },
  {
    "objectID": "data/sources.html",
    "href": "data/sources.html",
    "title": "Data Sources",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20251104_utah_county_municipal_general_election.json\nOriginal File Name: export-general11042025.json\n\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters\nFile Name: utah-county-ut_elections_general11042025_voters_body.html\n\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20250812_utah_county_municipal_primary_election.json\nOriginal File Name: export-primary08122025.json\n\n\n\n\n\nLink: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters\nFile Name: utah-county-ut_elections_primary08122025_voters_body.html\n\n\n\n\nThis CSV is the output of election_parsing.py:\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nimport numpy as np\nimport json\n\n###########\n\ndef parse_election_html(path, election_name):\n    soup = BeautifulSoup(Path(path).read_text(encoding=\"utf-8\"), \"html.parser\")\n\n    table = soup.select_one(\"table\")\n\n    def to_num(s: str):\n        s = re.sub(r\"[^0-9.-]\", \"\", re.sub(r\"[,\\u00A0]\", \"\", s.strip()))\n        return None if not s or s == \".\" else (float(s) if \".\" in s else int(s))\n\n    cols = [th.get_text(\" \", strip=True) for th in table.select(\"thead th\")][:4]\n\n    rows = []\n    for tr in table.select(\"tbody tr\"):\n        precinct = tr.find(\"th\", scope=\"row\").get_text(\" \", strip=True)\n\n        tds = tr.find_all(\"td\")[:3]\n        nums = [to_num(td.get_text(\" \", strip=True)) for td in tds]\n\n        rows.append([precinct, *nums])\n\n    df = pd\\\n        .DataFrame(\n            rows, \n            columns=[\"_\".join(c.lower().split()) for c in cols])\\\n        .assign(election_name = election_name)\\\n        .rename(columns={\n            \"precinct\": \"precinct_code\",\n            \"ballots_cast\": \"precinct_ballots_cast\",\n            \"registered_voters\": \"precinct_registered_voters\"})\n\n    return df\n\ndef parse_election_json(path, county=\"Utah County\"):\n\n    JSON = json.loads(Path(path).read_text(encoding=\"utf-8-sig\"))\n\n    def as_list(x):\n        return x if isinstance(x, list) else []\n\n    rows = []\n\n    for county in as_list(JSON.get(\"localResults\")):\n        if not isinstance(county, dict):\n            continue\n\n        county_id = county.get(\"id\")\n        county_name = county.get(\"name\")\n\n        for contest in as_list(county.get(\"ballotItems\")):\n            if not isinstance(contest, dict):\n                continue\n\n            contest_id = contest.get(\"id\")\n            contest_name = contest.get(\"name\")\n            contest_type = contest.get(\"type\")\n            contest_vote_for = contest.get(\"voteFor\")\n            contest_ballot_order = contest.get(\"ballotOrder\")\n\n            for opt in as_list(contest.get(\"ballotOptions\")):\n                if not isinstance(opt, dict):\n                    continue\n\n                opt_core = {\n                    \"election_date\": JSON.get(\"electionDate\"),\n                    \"election_name\": JSON.get(\"electionName\"),\n                    \"county_id\": county_id,\n                    \"county_name\": county_name,\n                    \"contest_id\": contest_id,\n                    \"contest_name\": contest_name,\n                    \"contest_type\": contest_type,\n                    \"contest_vote_for\": contest_vote_for,\n                    \"contest_ballot_order\": contest_ballot_order,\n                    \"choice_id\": opt.get(\"id\"),\n                    \"choice_name\": opt.get(\"name\"),\n                    \"choice_ballot_order\": opt.get(\"ballotOrder\"),\n                    \"choice_votes\": opt.get(\"voteCount\"),\n                    \"choice_party\": opt.get(\"politicalParty\") or None,\n                }\n\n                for pr in as_list(opt.get(\"precinctResults\")):\n                    if not isinstance(pr, dict):\n                        continue\n                    rows.append({**opt_core, **pr})\n\n    return pd\\\n        .DataFrame(rows)\\\n        .pipe(lambda df:\n            pd.json_normalize(df.to_dict(orient=\"records\"), sep=\".\"))\\\n        .rename({\n            \"name\": \"precinct_code\",\n            \"voteCount\": \"precinct_votes\"}, axis=1)\\\n        .filter(items=[\n            \"election_date\",\n            \"election_name\",\n            \"county_name\",\n            \"contest_name\",\n            \"contest_type\",\n            \"choice_name\",\n            \"precinct_code\",\n            \"precinct_votes\"])\n\ndef add_turnout_metrics(df):\n    return df\\\n    .assign(\n        is_zero_registration_precinct = pd.col(\"voter_registration\").eq(0),\n        is_zero_ballots_precinct = pd.col(\"precinct_ballots_cast\").eq(0),\n        turnout_rate_precinct = pd.col(\"voter_turnout\") / pd.col(\"voter_registration\"))\\\n    .assign(\n        turnout_rate_pct_precinct = pd.col(\"turnout_rate_precinct\").rank(pct=True, method=\"average\", na_option=\"keep\"))\n\ndef add_election_metrics(df):\n    return df\\\n        .assign(\n\n            # --- Contest vote distribution (per contest × precinct) ---\n            contest_total_votes=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"sum\"),\n\n            choice_share=(\n                (pd.col(\"precinct_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            choice_rank=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].rank(method=\"dense\", ascending=False),\n\n            polarization_fragmentation=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\n                    lambda s: (1 - np.square(s / s.sum()).sum()) if s.sum() &gt; 0 else np.nan)),\n\n            # --- Contest engagement (ballots that participated in the contest) ---\n            contest_participation_rate=(\n                (pd.col(\"contest_total_votes\") / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_count=(\n                (pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_rate=(\n                ((pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\")) / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n\n            # --- Outcome summary (winner / runner-up / margins) ---\n            winner_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"max\")\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n            runnerup_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"]\n                .transform(lambda s: (s.nlargest(2).iloc[1] if len(s) &gt; 1 else 0))\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n\n            margin_votes=(\n                (pd.col(\"winner_votes\") - pd.col(\"runnerup_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            margin_pct=(\n                (pd.col(\"margin_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            winner_share=(\n                (pd.col(\"winner_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            runnerup_share=(\n                (pd.col(\"runnerup_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            # --- Human-readable labels (ties become \"A | B\") ---\n            winner_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 1)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)),\n            runnerup_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 2)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)))\\\n        .sort_values(KEYS_PC + [\"precinct_votes\"], ascending=[True, True, True, True, False])\n\n###########\n\ndf_primary_json = parse_election_json(r\"20250812_utah_county_municipal_primary_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_general_json = parse_election_json(r\"20251104_utah_county_municipal_general_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_primary_totals = parse_election_html(r\"utah-county-ut_elections_primary08122025_voters_body.html\", \"2025 Utah Municipal Primary\")\\\n    .pipe(add_turnout_metrics)\n\ndf_general_totals = parse_election_html(r\"utah-county-ut_elections_general11042025_voters_body.html\", \"2025 Utah Municipal General Election\")\\\n    .pipe(add_turnout_metrics)\n\n\n###########\n\nKEYS_PC = [\"election_name\", \"county_name\", \"contest_name\", \"precinct_code\"]\n\ndf_general = df_general_json\\\n    .merge(\n        df_general_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n    \ndf_primary = df_primary_json\\\n    .merge(\n        df_primary_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n\n###########\n\nutah_county_elections = pd.concat([df_primary, df_general], ignore_index=True)\n\nutah_county_elections.to_csv(\"utah_county_elections.csv\", index=False)\n\n\nGrain: Each row represents one choice_name (candidate / YES / NO / etc.) within one contest_name within one precinct_code for a given election_name.\nBecause of that grain, precinct-wide totals (like registration, ballots cast) and contest-wide totals (like contest_total_votes) repeat across multiple rows (one per choice).\n\n\n\n\nelection_date (str)\nDate of the election in YYYY-MM-DD form (as provided by the source).\nExample: 2025-11-04.\nelection_name (str)\nHuman-readable election label (as provided by the source).\nExample: 2025 Utah Municipal General Election.\ncounty_name (str)\nCounty label (\"Utah County\" here).\n\n\n\n\n\ncontest_name (str)\nThe race/measure name as shown in results.\nExamples: \"Saratoga Springs Mayor\", \"School Board Lake Mountain 5\", \"Proposition #8 Eagle Mountain\".\ncontest_type (str)\nHigh-level contest category from the source (often \"Local\" in municipal datasets).\nchoice_name (str)\nThe selectable option within a contest (candidate name, \"YES\", \"NO\", write-in bucket, etc.).\n\n\n\n\n\nprecinct_code (str)\nPrecinct identifier used to join precinct-level results and turnout totals.\nExample: \"25SR15\".\n\n\n\n\n\nprecinct_votes (int)\nVotes recorded for this specific choice_name in this precinct for this contest.\n(This is the numerator for choice_share.)\nprecinct_ballots_cast (int)\nTotal ballots cast in the precinct for the election (precinct-wide).\nRepeats for all rows belonging to that precinct within the election.\nvoter_turnout (int)\nTurnout count for the precinct (precinct-wide).\nIn many exports this equals precinct_ballots_cast; if they differ, treat voter_turnout as the official turnout figure.\nvoter_registration (int)\nRegistered voters in the precinct (precinct-wide).\n\n\n\n\n\nis_zero_registration_precinct (bool)\nConvenience flag:\nvoter_registration == 0\nUseful to avoid divide-by-zero and to quickly locate placeholder/invalid precinct records.\nis_zero_ballots_precinct (bool)\nConvenience flag:\nprecinct_ballots_cast == 0\nUseful to identify precincts with no reported ballots or incomplete reporting.\n\n\n\n\n\nturnout_rate_precinct (float)\nTurnout fraction in the precinct:\nturnout_rate_precinct = voter_turnout / voter_registration\nTypically NaN (or undefined) if voter_registration == 0.\nturnout_rate_pct_precinct (float)\nPercent form of turnout:\nturnout_rate_pct_precinct = 100 * turnout_rate_precinct\n\n\n\n\n\ncontest_total_votes (int)\nTotal votes recorded in this contest in this precinct, across all choices:\ncontest_total_votes = Σ precinct_votes over all choice_name within the same\n(election_name, county_name, contest_name, precinct_code) group.\nInterpretation note: For multi-seat contests (e.g., “vote for up to 2”), contest_total_votes can be greater than precinct_ballots_cast.\nchoice_share (float)\nShare of the contest vote for this choice in this precinct:\nchoice_share = precinct_votes / contest_total_votes (when contest_total_votes &gt; 0).\nchoice_rank (float)\nRank of this choice by precinct_votes within the contest/precinct group (dense ranking, descending):\nchoice_rank = rank_dense_desc(precinct_votes within group)\n\n1 = top vote-getter(s)\n\nTies share the same rank\n\nNext rank increments by 1 (dense)\n\npolarization_fragmentation (float)\nA concentration/fragmentation index derived from vote shares (Simpson-style):\nLet p_i = precinct_votes_i / contest_total_votes for each choice in the group.\nThen:\npolarization_fragmentation = 1 - Σ(p_i^2) (when contest_total_votes &gt; 0)\nInterpretation:\n\nNear 0 → highly concentrated (one option dominates)\nLarger values → more fragmented (votes spread across options)\nMaximum depends on number of choices (more choices can raise the maximum)\n\n\n\n\n\nThese are computed using precinct_ballots_cast as a denominator.\n\ncontest_participation_rate (float)\nRate of ballots that recorded a vote in the contest (proxy):\ncontest_participation_rate = contest_total_votes / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nImportant interpretation note:\nThis behaves as expected for single-choice contests (mayor, proposition yes/no, etc.).\nFor multi-seat contests, contest_total_votes can exceed precinct_ballots_cast, so this can be &gt; 1 and should be interpreted as “votes per ballot” rather than “participation.”\nrolloff_count (float)\nBallots that did not record a vote in this contest (proxy):\nrolloff_count = precinct_ballots_cast - contest_total_votes (when precinct_ballots_cast &gt; 0)\nNote: Can be negative in multi-seat contests (because contest_total_votes may exceed ballots cast).\nIf you want a “never negative” roll-off for mapping, a common variant is:\nrolloff_count_clipped = max(rolloff_count, 0).\nrolloff_rate (float)\nRoll-off fraction:\nrolloff_rate = rolloff_count / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nSame caveat: may be negative for multi-seat contests.\n\n\n\n\nThese values repeat for every choice_name row inside the same contest/precinct group.\n\nwinner_votes (float)\nTop vote total in the contest/precinct group:\nwinner_votes = max(precinct_votes within group) (when contest_total_votes &gt; 0)\nrunnerup_votes (float)\nSecond-highest vote total in the group:\nrunnerup_votes = 2nd_largest(precinct_votes within group) (when contest_total_votes &gt; 0)\nEdge case:\n\nIf the contest has only one reported choice in the group, this may be set to 0 (or could be NaN depending on implementation preference).\n\nmargin_votes (float)\nVote margin between the top two choices:\nmargin_votes = winner_votes - runnerup_votes (when contest_total_votes &gt; 0)\nmargin_pct (float)\nMargin as a fraction of contest votes:\nmargin_pct = margin_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_share (float)\nWinner’s share of the contest vote:\nwinner_share = winner_votes / contest_total_votes (when contest_total_votes &gt; 0)\nrunnerup_share (float)\nRunner-up’s share of the contest vote:\nrunnerup_share = runnerup_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_choice_name (str)\nName(s) of the winning choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 1.\nIf there is a tie for first, names may be joined like: \"A | B\".\nrunnerup_choice_name (object / str; may contain NaN)\nName(s) of the 2nd-place choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 2.\nCan be NaN when there is no runner-up (e.g., uncontested contests or only one reported choice).\n\nNote: For multi-seat contests (like many “City Council” contests), you may observe: - contest_total_votes &gt; precinct_ballots_cast - therefore rolloff_count &lt; 0 and rolloff_rate &lt; 0\nThis does not necessarily indicate bad data; it usually means the contest allows selecting multiple candidates (so ballots can contribute multiple votes)."
  },
  {
    "objectID": "data/sources.html#utah-county-precinct-boundaries",
    "href": "data/sources.html#utah-county-precinct-boundaries",
    "title": "Data Sources",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson"
  },
  {
    "objectID": "data/sources.html#turnout-data",
    "href": "data/sources.html#turnout-data",
    "title": "Data Sources",
    "section": "",
    "text": "2025-11-04 Utah County Municipal General Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters * File Name: 20251104_utah_county_municipal_general_election.json * Original File Name: export-general11042025.json\n2025-08-12 Utah County Municipal Primary Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters * File Name: 20250812_utah_county_municipal_primary_election.json * Original File Name: export-primary08122025.json\n2024-11-05 Utah County General Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11052024/voters * File Name: 20241105_utah_county_general_election.json * Original File Name: export-general11052024.json\n2024-06-25 Utah County Primary Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary06252024/voters * File Name: 20240625_utah_county_primary_election.json * Original File Name: export-primary06252024.json\n2024-03-05 Utah County Presidential Preference Primary Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary03052024/voters * File Name: 20Original File Name: 240305_utah_county_presidential_preference_primary_election.json * export-primary03052024.json\n2023-11-21 Utah County General Election * Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/2023-Nov-General/voters * File Name: 20231121_utah_county_general_election.json * Original File Name: export-2023-Nov-General.json"
  },
  {
    "objectID": "data/sources.html#utah-vista-ballot-areas-precinct-boundaries",
    "href": "data/sources.html#utah-vista-ballot-areas-precinct-boundaries",
    "title": "Data Sources",
    "section": "",
    "text": "Statewide ballot area polygons were downloaded from Utah’s Open Data Portal:\n\nDataset: Utah VISTA Ballot Areas\nURL: https://opendata.gis.utah.gov/datasets/utah::utah-vista-ballot-areas/about\nOriginal file: VistaBallotAreas_-1176372527926423573.geojson\n\nProcessing:\n\nLoad the statewide GeoJSON\nFilter to Utah County using CountyID == 25:\nKeep only required fields: ['CountyID', 'PrecinctID', 'SubPrecinctID', 'geometry']\nReproject for web mapping: WGS84 (EPSG:4326)\nLightly simplify geometry for performance: tolerance = 0.0001\n\nOutput: data/geo/utah_county_precincts.min.geojson"
  },
  {
    "objectID": "data/sources.html#utah-county-municipal-general-election-json-data",
    "href": "data/sources.html#utah-county-municipal-general-election-json-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20251104_utah_county_municipal_general_election.json\nOriginal File Name: export-general11042025.json"
  },
  {
    "objectID": "data/sources.html#utah-municipal-general-election-voter-turnout-html-data",
    "href": "data/sources.html#utah-municipal-general-election-voter-turnout-html-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/general11042025/voters\nFile Name: utah-county-ut_elections_general11042025_voters_body.html"
  },
  {
    "objectID": "data/sources.html#utah-county-municipal-primary-json-data",
    "href": "data/sources.html#utah-county-municipal-primary-json-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters (Under: Utah Election Night Reporting Media Export)\nFile Name: 20250812_utah_county_municipal_primary_election.json\nOriginal File Name: export-primary08122025.json"
  },
  {
    "objectID": "data/sources.html#utah-municipal-primary-voter-turnout-html-data",
    "href": "data/sources.html#utah-municipal-primary-voter-turnout-html-data",
    "title": "Data Sources",
    "section": "",
    "text": "Link: https://electionresults.utah.gov/results/public/utah-county-ut/elections/primary08122025/voters\nFile Name: utah-county-ut_elections_primary08122025_voters_body.html"
  },
  {
    "objectID": "data/sources.html#utah_county_elections.csv",
    "href": "data/sources.html#utah_county_elections.csv",
    "title": "Data Sources",
    "section": "",
    "text": "This CSV is the output of election_parsing.py:\nfrom pathlib import Path\nfrom bs4 import BeautifulSoup\nimport re\nimport pandas as pd\nimport numpy as np\nimport json\n\n###########\n\ndef parse_election_html(path, election_name):\n    soup = BeautifulSoup(Path(path).read_text(encoding=\"utf-8\"), \"html.parser\")\n\n    table = soup.select_one(\"table\")\n\n    def to_num(s: str):\n        s = re.sub(r\"[^0-9.-]\", \"\", re.sub(r\"[,\\u00A0]\", \"\", s.strip()))\n        return None if not s or s == \".\" else (float(s) if \".\" in s else int(s))\n\n    cols = [th.get_text(\" \", strip=True) for th in table.select(\"thead th\")][:4]\n\n    rows = []\n    for tr in table.select(\"tbody tr\"):\n        precinct = tr.find(\"th\", scope=\"row\").get_text(\" \", strip=True)\n\n        tds = tr.find_all(\"td\")[:3]\n        nums = [to_num(td.get_text(\" \", strip=True)) for td in tds]\n\n        rows.append([precinct, *nums])\n\n    df = pd\\\n        .DataFrame(\n            rows, \n            columns=[\"_\".join(c.lower().split()) for c in cols])\\\n        .assign(election_name = election_name)\\\n        .rename(columns={\n            \"precinct\": \"precinct_code\",\n            \"ballots_cast\": \"precinct_ballots_cast\",\n            \"registered_voters\": \"precinct_registered_voters\"})\n\n    return df\n\ndef parse_election_json(path, county=\"Utah County\"):\n\n    JSON = json.loads(Path(path).read_text(encoding=\"utf-8-sig\"))\n\n    def as_list(x):\n        return x if isinstance(x, list) else []\n\n    rows = []\n\n    for county in as_list(JSON.get(\"localResults\")):\n        if not isinstance(county, dict):\n            continue\n\n        county_id = county.get(\"id\")\n        county_name = county.get(\"name\")\n\n        for contest in as_list(county.get(\"ballotItems\")):\n            if not isinstance(contest, dict):\n                continue\n\n            contest_id = contest.get(\"id\")\n            contest_name = contest.get(\"name\")\n            contest_type = contest.get(\"type\")\n            contest_vote_for = contest.get(\"voteFor\")\n            contest_ballot_order = contest.get(\"ballotOrder\")\n\n            for opt in as_list(contest.get(\"ballotOptions\")):\n                if not isinstance(opt, dict):\n                    continue\n\n                opt_core = {\n                    \"election_date\": JSON.get(\"electionDate\"),\n                    \"election_name\": JSON.get(\"electionName\"),\n                    \"county_id\": county_id,\n                    \"county_name\": county_name,\n                    \"contest_id\": contest_id,\n                    \"contest_name\": contest_name,\n                    \"contest_type\": contest_type,\n                    \"contest_vote_for\": contest_vote_for,\n                    \"contest_ballot_order\": contest_ballot_order,\n                    \"choice_id\": opt.get(\"id\"),\n                    \"choice_name\": opt.get(\"name\"),\n                    \"choice_ballot_order\": opt.get(\"ballotOrder\"),\n                    \"choice_votes\": opt.get(\"voteCount\"),\n                    \"choice_party\": opt.get(\"politicalParty\") or None,\n                }\n\n                for pr in as_list(opt.get(\"precinctResults\")):\n                    if not isinstance(pr, dict):\n                        continue\n                    rows.append({**opt_core, **pr})\n\n    return pd\\\n        .DataFrame(rows)\\\n        .pipe(lambda df:\n            pd.json_normalize(df.to_dict(orient=\"records\"), sep=\".\"))\\\n        .rename({\n            \"name\": \"precinct_code\",\n            \"voteCount\": \"precinct_votes\"}, axis=1)\\\n        .filter(items=[\n            \"election_date\",\n            \"election_name\",\n            \"county_name\",\n            \"contest_name\",\n            \"contest_type\",\n            \"choice_name\",\n            \"precinct_code\",\n            \"precinct_votes\"])\n\ndef add_turnout_metrics(df):\n    return df\\\n    .assign(\n        is_zero_registration_precinct = pd.col(\"voter_registration\").eq(0),\n        is_zero_ballots_precinct = pd.col(\"precinct_ballots_cast\").eq(0),\n        turnout_rate_precinct = pd.col(\"voter_turnout\") / pd.col(\"voter_registration\"))\\\n    .assign(\n        turnout_rate_pct_precinct = pd.col(\"turnout_rate_precinct\").rank(pct=True, method=\"average\", na_option=\"keep\"))\n\ndef add_election_metrics(df):\n    return df\\\n        .assign(\n\n            # --- Contest vote distribution (per contest × precinct) ---\n            contest_total_votes=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"sum\"),\n\n            choice_share=(\n                (pd.col(\"precinct_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            choice_rank=lambda d: d.groupby(KEYS_PC)[\"precinct_votes\"].rank(method=\"dense\", ascending=False),\n\n            polarization_fragmentation=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\n                    lambda s: (1 - np.square(s / s.sum()).sum()) if s.sum() &gt; 0 else np.nan)),\n\n            # --- Contest engagement (ballots that participated in the contest) ---\n            contest_participation_rate=(\n                (pd.col(\"contest_total_votes\") / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_count=(\n                (pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n            rolloff_rate=(\n                ((pd.col(\"precinct_ballots_cast\") - pd.col(\"contest_total_votes\")) / pd.col(\"precinct_ballots_cast\"))\n                .where(pd.col(\"precinct_ballots_cast\") &gt; 0)),\n\n            # --- Outcome summary (winner / runner-up / margins) ---\n            winner_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"].transform(\"max\")\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n            runnerup_votes=lambda d: (\n                d.groupby(KEYS_PC)[\"precinct_votes\"]\n                .transform(lambda s: (s.nlargest(2).iloc[1] if len(s) &gt; 1 else 0))\n                .where(d[\"contest_total_votes\"] &gt; 0)),\n\n            margin_votes=(\n                (pd.col(\"winner_votes\") - pd.col(\"runnerup_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            margin_pct=(\n                (pd.col(\"margin_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            winner_share=(\n                (pd.col(\"winner_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n            runnerup_share=(\n                (pd.col(\"runnerup_votes\") / pd.col(\"contest_total_votes\"))\n                .where(pd.col(\"contest_total_votes\") &gt; 0)),\n\n            # --- Human-readable labels (ties become \"A | B\") ---\n            winner_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 1)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)),\n            runnerup_choice_name=lambda d: (\n                d[\"choice_name\"]\n                .where(d[\"choice_rank\"] == 2)\n                .groupby([d[c] for c in KEYS_PC])\n                .transform(lambda s: \" | \".join(pd.unique(s.dropna())) if s.notna().any() else np.nan)))\\\n        .sort_values(KEYS_PC + [\"precinct_votes\"], ascending=[True, True, True, True, False])\n\n###########\n\ndf_primary_json = parse_election_json(r\"20250812_utah_county_municipal_primary_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_general_json = parse_election_json(r\"20251104_utah_county_municipal_general_election.json\")\\\n        .loc[pd.col(\"county_name\").str.contains(\"Utah\", case=False, na=False)]\n\ndf_primary_totals = parse_election_html(r\"utah-county-ut_elections_primary08122025_voters_body.html\", \"2025 Utah Municipal Primary\")\\\n    .pipe(add_turnout_metrics)\n\ndf_general_totals = parse_election_html(r\"utah-county-ut_elections_general11042025_voters_body.html\", \"2025 Utah Municipal General Election\")\\\n    .pipe(add_turnout_metrics)\n\n\n###########\n\nKEYS_PC = [\"election_name\", \"county_name\", \"contest_name\", \"precinct_code\"]\n\ndf_general = df_general_json\\\n    .merge(\n        df_general_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n    \ndf_primary = df_primary_json\\\n    .merge(\n        df_primary_totals,\n        how=\"left\",\n        on=[\"election_name\", \"precinct_code\"])\\\n    .pipe(add_election_metrics)\n\n###########\n\nutah_county_elections = pd.concat([df_primary, df_general], ignore_index=True)\n\nutah_county_elections.to_csv(\"utah_county_elections.csv\", index=False)\n\n\nGrain: Each row represents one choice_name (candidate / YES / NO / etc.) within one contest_name within one precinct_code for a given election_name.\nBecause of that grain, precinct-wide totals (like registration, ballots cast) and contest-wide totals (like contest_total_votes) repeat across multiple rows (one per choice).\n\n\n\n\nelection_date (str)\nDate of the election in YYYY-MM-DD form (as provided by the source).\nExample: 2025-11-04.\nelection_name (str)\nHuman-readable election label (as provided by the source).\nExample: 2025 Utah Municipal General Election.\ncounty_name (str)\nCounty label (\"Utah County\" here).\n\n\n\n\n\ncontest_name (str)\nThe race/measure name as shown in results.\nExamples: \"Saratoga Springs Mayor\", \"School Board Lake Mountain 5\", \"Proposition #8 Eagle Mountain\".\ncontest_type (str)\nHigh-level contest category from the source (often \"Local\" in municipal datasets).\nchoice_name (str)\nThe selectable option within a contest (candidate name, \"YES\", \"NO\", write-in bucket, etc.).\n\n\n\n\n\nprecinct_code (str)\nPrecinct identifier used to join precinct-level results and turnout totals.\nExample: \"25SR15\".\n\n\n\n\n\nprecinct_votes (int)\nVotes recorded for this specific choice_name in this precinct for this contest.\n(This is the numerator for choice_share.)\nprecinct_ballots_cast (int)\nTotal ballots cast in the precinct for the election (precinct-wide).\nRepeats for all rows belonging to that precinct within the election.\nvoter_turnout (int)\nTurnout count for the precinct (precinct-wide).\nIn many exports this equals precinct_ballots_cast; if they differ, treat voter_turnout as the official turnout figure.\nvoter_registration (int)\nRegistered voters in the precinct (precinct-wide).\n\n\n\n\n\nis_zero_registration_precinct (bool)\nConvenience flag:\nvoter_registration == 0\nUseful to avoid divide-by-zero and to quickly locate placeholder/invalid precinct records.\nis_zero_ballots_precinct (bool)\nConvenience flag:\nprecinct_ballots_cast == 0\nUseful to identify precincts with no reported ballots or incomplete reporting.\n\n\n\n\n\nturnout_rate_precinct (float)\nTurnout fraction in the precinct:\nturnout_rate_precinct = voter_turnout / voter_registration\nTypically NaN (or undefined) if voter_registration == 0.\nturnout_rate_pct_precinct (float)\nPercent form of turnout:\nturnout_rate_pct_precinct = 100 * turnout_rate_precinct\n\n\n\n\n\ncontest_total_votes (int)\nTotal votes recorded in this contest in this precinct, across all choices:\ncontest_total_votes = Σ precinct_votes over all choice_name within the same\n(election_name, county_name, contest_name, precinct_code) group.\nInterpretation note: For multi-seat contests (e.g., “vote for up to 2”), contest_total_votes can be greater than precinct_ballots_cast.\nchoice_share (float)\nShare of the contest vote for this choice in this precinct:\nchoice_share = precinct_votes / contest_total_votes (when contest_total_votes &gt; 0).\nchoice_rank (float)\nRank of this choice by precinct_votes within the contest/precinct group (dense ranking, descending):\nchoice_rank = rank_dense_desc(precinct_votes within group)\n\n1 = top vote-getter(s)\n\nTies share the same rank\n\nNext rank increments by 1 (dense)\n\npolarization_fragmentation (float)\nA concentration/fragmentation index derived from vote shares (Simpson-style):\nLet p_i = precinct_votes_i / contest_total_votes for each choice in the group.\nThen:\npolarization_fragmentation = 1 - Σ(p_i^2) (when contest_total_votes &gt; 0)\nInterpretation:\n\nNear 0 → highly concentrated (one option dominates)\nLarger values → more fragmented (votes spread across options)\nMaximum depends on number of choices (more choices can raise the maximum)\n\n\n\n\n\nThese are computed using precinct_ballots_cast as a denominator.\n\ncontest_participation_rate (float)\nRate of ballots that recorded a vote in the contest (proxy):\ncontest_participation_rate = contest_total_votes / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nImportant interpretation note:\nThis behaves as expected for single-choice contests (mayor, proposition yes/no, etc.).\nFor multi-seat contests, contest_total_votes can exceed precinct_ballots_cast, so this can be &gt; 1 and should be interpreted as “votes per ballot” rather than “participation.”\nrolloff_count (float)\nBallots that did not record a vote in this contest (proxy):\nrolloff_count = precinct_ballots_cast - contest_total_votes (when precinct_ballots_cast &gt; 0)\nNote: Can be negative in multi-seat contests (because contest_total_votes may exceed ballots cast).\nIf you want a “never negative” roll-off for mapping, a common variant is:\nrolloff_count_clipped = max(rolloff_count, 0).\nrolloff_rate (float)\nRoll-off fraction:\nrolloff_rate = rolloff_count / precinct_ballots_cast (when precinct_ballots_cast &gt; 0)\nSame caveat: may be negative for multi-seat contests.\n\n\n\n\nThese values repeat for every choice_name row inside the same contest/precinct group.\n\nwinner_votes (float)\nTop vote total in the contest/precinct group:\nwinner_votes = max(precinct_votes within group) (when contest_total_votes &gt; 0)\nrunnerup_votes (float)\nSecond-highest vote total in the group:\nrunnerup_votes = 2nd_largest(precinct_votes within group) (when contest_total_votes &gt; 0)\nEdge case:\n\nIf the contest has only one reported choice in the group, this may be set to 0 (or could be NaN depending on implementation preference).\n\nmargin_votes (float)\nVote margin between the top two choices:\nmargin_votes = winner_votes - runnerup_votes (when contest_total_votes &gt; 0)\nmargin_pct (float)\nMargin as a fraction of contest votes:\nmargin_pct = margin_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_share (float)\nWinner’s share of the contest vote:\nwinner_share = winner_votes / contest_total_votes (when contest_total_votes &gt; 0)\nrunnerup_share (float)\nRunner-up’s share of the contest vote:\nrunnerup_share = runnerup_votes / contest_total_votes (when contest_total_votes &gt; 0)\nwinner_choice_name (str)\nName(s) of the winning choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 1.\nIf there is a tie for first, names may be joined like: \"A | B\".\nrunnerup_choice_name (object / str; may contain NaN)\nName(s) of the 2nd-place choice(s) in that contest/precinct group.\nComputed by selecting choice_name where choice_rank == 2.\nCan be NaN when there is no runner-up (e.g., uncontested contests or only one reported choice).\n\nNote: For multi-seat contests (like many “City Council” contests), you may observe: - contest_total_votes &gt; precinct_ballots_cast - therefore rolloff_count &lt; 0 and rolloff_rate &lt; 0\nThis does not necessarily indicate bad data; it usually means the contest allows selecting multiple candidates (so ballots can contribute multiple votes)."
  }
]