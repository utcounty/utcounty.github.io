<script>
  (function () {
    // =========================================================
    // Config (maintainability)
    // =========================================================
    const CFG = {
      csvUrl: "data/to/utah_county_elections.csv",

      // Join key from the map
      precinctField: "precinct_code",

      // Election identity
      electionDateField: "election_date",
      electionNameField: "election_name",

      // Grouping
      contestField: "contest_name",
      contestTypeField: "contest_type",
      choiceField: "choice_name",

      // Metrics
      votesField: "precinct_votes",
      ballotsCastField: "precinct_ballots_cast",
      turnoutField: "voter_turnout",
      registrationField: "voter_registration",
      turnoutRateField: "turnout_rate_precinct",

      // Contest summary (repeated per choice row)
      contestTotalVotesField: "contest_total_votes",
      contestParticipationRateField: "contest_participation_rate",
      rolloffRateField: "rolloff_rate",
      polarizationField: "polarization_fragmentation",

      // Outcome summary (repeated per choice row)
      winnerChoiceField: "winner_choice_name",
      runnerupChoiceField: "runnerup_choice_name",
      winnerVotesField: "winner_votes",
      runnerupVotesField: "runnerup_votes",
      marginVotesField: "margin_votes",
      marginPctField: "margin_pct",

      // Choice detail
      choiceShareField: "choice_share",
      choiceRankField: "choice_rank",
    };

    // =========================================================
    // DOM
    // =========================================================
    const ui = {
      electionSelect: document.getElementById("electionSelect"),
      reportBox: document.getElementById("reportBox"),
    };

    // =========================================================
    // State / Indexes
    // =========================================================
    const state = {
      loaded: false,
      elections: [], // [{ key, date, name, label }]
      activeElectionKey: "",

      // electionKey -> precinctCode -> contestName -> rows[]
      idx: new Map(),

      // electionKey|precinctCode -> { ballotsCast, turnout, registration, turnoutRate }
      precinctMeta: new Map(),
    };

    // =========================================================
    // Small utilities
    // =========================================================
    const esc = (s) =>
      String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");

    const norm = (v) => (v ?? "").toString().trim();

    const toNum = (v) => {
      if (v === null || v === undefined) return null;
      const s = String(v).trim();
      if (!s) return null;
      const n = Number(s);
      return Number.isFinite(n) ? n : null;
    };

    const fmtInt = (n) => (Number.isFinite(n) ? Math.round(n).toLocaleString() : "—");
    const fmtPct = (x, digits = 1) =>
      Number.isFinite(x) ? `${(x * 100).toFixed(digits)}%` : "—";
    const fmtPctAbs = (x, digits = 1) =>
      Number.isFinite(x) ? `${x.toFixed(digits)}%` : "—";
    const fmtFloat = (x, digits = 3) =>
      Number.isFinite(x) ? x.toFixed(digits) : "—";

    function setReport(html) {
      if (!ui.reportBox) return;
      ui.reportBox.innerHTML = html;
    }

    function setElectionSelectOptions() {
      if (!ui.electionSelect) return;

      if (!state.elections.length) {
        ui.electionSelect.innerHTML = `<option value="">No elections found</option>`;
        return;
      }

      // Default election: latest date (already sorted desc)
      if (!state.activeElectionKey) state.activeElectionKey = state.elections[0].key;

      ui.electionSelect.innerHTML = state.elections
        .map((e) => {
          const sel = e.key === state.activeElectionKey ? "selected" : "";
          return `<option value="${esc(e.key)}" ${sel}>${esc(e.label)}</option>`;
        })
        .join("");
    }

    // =========================================================
    // CSV parsing (simple + quote-aware per line)
    // =========================================================
    function splitCSVLine(line) {
      const out = [];
      let cur = "";
      let inQ = false;

      for (let i = 0; i < line.length; i++) {
        const c = line[i];

        if (c === '"') {
          // escaped quote
          if (inQ && line[i + 1] === '"') {
            cur += '"';
            i++;
          } else {
            inQ = !inQ;
          }
        } else if (c === "," && !inQ) {
          out.push(cur);
          cur = "";
        } else {
          cur += c;
        }
      }
      out.push(cur);
      return out;
    }

    function parseCSV(text) {
      const lines = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
      const nonEmpty = lines.filter((l) => l.trim().length > 0);
      if (!nonEmpty.length) return [];

      const header = splitCSVLine(nonEmpty[0]).map((h) => h.trim());
      const rows = [];

      for (let i = 1; i < nonEmpty.length; i++) {
        const cols = splitCSVLine(nonEmpty[i]);
        if (!cols.length) continue;

        const obj = {};
        for (let j = 0; j < header.length; j++) {
          obj[header[j]] = cols[j] ?? "";
        }
        rows.push(obj);
      }

      return rows;
    }

    // =========================================================
    // Index building
    // =========================================================
    function electionKey(row) {
      const d = norm(row[CFG.electionDateField]);
      const n = norm(row[CFG.electionNameField]);
      return `${d}|${n}`;
    }

    function buildIndexes(rows) {
      const electionSeen = new Map(); // key -> {date,name}

      for (const r0 of rows) {
        const r = r0;

        // normalize strings
        const precinct = norm(r[CFG.precinctField]).toUpperCase();
        const eDate = norm(r[CFG.electionDateField]);
        const eName = norm(r[CFG.electionNameField]);
        const contest = norm(r[CFG.contestField]);
        const contestType = norm(r[CFG.contestTypeField]);
        const choice = norm(r[CFG.choiceField]);

        if (!precinct || !eName || !eDate || !contest || !choice) continue;

        // cast numeric-ish fields
        const votes = toNum(r[CFG.votesField]);
        const ballotsCast = toNum(r[CFG.ballotsCastField]);
        const turnout = toNum(r[CFG.turnoutField]);
        const registration = toNum(r[CFG.registrationField]);
        const turnoutRate = toNum(r[CFG.turnoutRateField]);

        const contestTotalVotes = toNum(r[CFG.contestTotalVotesField]);
        const contestParticipationRate = toNum(r[CFG.contestParticipationRateField]);
        const rolloffRate = toNum(r[CFG.rolloffRateField]);
        const polarization = toNum(r[CFG.polarizationField]);

        const winnerVotes = toNum(r[CFG.winnerVotesField]);
        const runnerupVotes = toNum(r[CFG.runnerupVotesField]);
        const marginVotes = toNum(r[CFG.marginVotesField]);
        const marginPct = toNum(r[CFG.marginPctField]);

        const choiceShare = toNum(r[CFG.choiceShareField]);
        const choiceRank = toNum(r[CFG.choiceRankField]);

        const winnerChoiceName = norm(r[CFG.winnerChoiceField]);
        const runnerupChoiceName = norm(r[CFG.runnerupChoiceField]);

        const ek = `${eDate}|${eName}`;
        electionSeen.set(ek, { date: eDate, name: eName });

        // idx init
        if (!state.idx.has(ek)) state.idx.set(ek, new Map());
        const eMap = state.idx.get(ek);

        if (!eMap.has(precinct)) eMap.set(precinct, new Map());
        const pMap = eMap.get(precinct);

        if (!pMap.has(contest)) pMap.set(contest, []);
        const bucket = pMap.get(contest);

        bucket.push({
          precinct,
          eDate,
          eName,
          contest,
          contestType,
          choice,

          votes,
          ballotsCast,
          turnout,
          registration,
          turnoutRate,

          contestTotalVotes,
          contestParticipationRate,
          rolloffRate,
          polarization,

          winnerChoiceName,
          runnerupChoiceName,
          winnerVotes,
          runnerupVotes,
          marginVotes,
          marginPct,

          choiceShare,
          choiceRank,
        });

        // precinct meta (store once)
        const metaKey = `${ek}|${precinct}`;
        if (!state.precinctMeta.has(metaKey)) {
          state.precinctMeta.set(metaKey, {
            ballotsCast,
            turnout,
            registration,
            turnoutRate,
          });
        } else {
          // fill blanks if needed
          const m = state.precinctMeta.get(metaKey);
          if (!Number.isFinite(m.ballotsCast) && Number.isFinite(ballotsCast)) m.ballotsCast = ballotsCast;
          if (!Number.isFinite(m.turnout) && Number.isFinite(turnout)) m.turnout = turnout;
          if (!Number.isFinite(m.registration) && Number.isFinite(registration)) m.registration = registration;
          if (!Number.isFinite(m.turnoutRate) && Number.isFinite(turnoutRate)) m.turnoutRate = turnoutRate;
        }
      }

      // elections list (sort desc by date)
      state.elections = Array.from(electionSeen.entries())
        .map(([key, v]) => ({
          key,
          date: v.date,
          name: v.name,
          label: `${v.date} · ${v.name}`,
        }))
        .sort((a, b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : a.name.localeCompare(b.name)));
    }

    // =========================================================
    // Rendering
    // =========================================================
    function contestSortKey(rows) {
      // prefer higher contest_total_votes, fallback to winner_votes
      const r = rows[0] || {};
      const a = Number.isFinite(r.contestTotalVotes) ? r.contestTotalVotes : -1;
      const b = Number.isFinite(r.winnerVotes) ? r.winnerVotes : -1;
      return a !== -1 ? a : b;
    }

    function renderContestBlock(contestName, rows) {
      // sort choices by rank then votes desc
      const sorted = [...rows].sort((a, b) => {
        const ar = Number.isFinite(a.choiceRank) ? a.choiceRank : 9999;
        const br = Number.isFinite(b.choiceRank) ? b.choiceRank : 9999;
        if (ar !== br) return ar - br;
        const av = Number.isFinite(a.votes) ? a.votes : -1;
        const bv = Number.isFinite(b.votes) ? b.votes : -1;
        return bv - av;
      });

      const r0 = sorted[0] || {};
      const winner = r0.winnerChoiceName || "—";
      const runner = r0.runnerupChoiceName || "—";

      const headerRight = `
        <div class="text-xs text-slate-500">
          <span class="font-semibold text-slate-700">${fmtInt(r0.contestTotalVotes)}</span> votes
          <span class="mx-2 text-slate-300">•</span>
          margin <span class="font-semibold text-slate-700">${fmtInt(r0.marginVotes)}</span>
          (${fmtPct(r0.marginPct, 1)})
        </div>
      `;

      const metaRow = `
        <div class="mt-3 grid gap-2 sm:grid-cols-3 text-xs text-slate-600">
          <div class="rounded-lg bg-slate-50 px-3 py-2">
            <div class="uppercase tracking-wide text-[10px] text-slate-500">Winner</div>
            <div class="font-semibold text-slate-900">${esc(winner)}</div>
          </div>
          <div class="rounded-lg bg-slate-50 px-3 py-2">
            <div class="uppercase tracking-wide text-[10px] text-slate-500">Runner-up</div>
            <div class="font-semibold text-slate-900">${esc(runner)}</div>
          </div>
          <div class="rounded-lg bg-slate-50 px-3 py-2">
            <div class="uppercase tracking-wide text-[10px] text-slate-500">Participation</div>
            <div class="font-semibold text-slate-900">
              ${fmtFloat(r0.contestParticipationRate, 3)}
              <span class="text-slate-500 font-normal">(votes/ballot)</span>
            </div>
          </div>
        </div>
      `;

      const tableRows = sorted
        .map((x) => {
          const share = fmtPct(x.choiceShare, 1);
          return `
            <tr class="border-t border-slate-200">
              <td class="px-3 py-2 text-slate-900">${esc(x.choice)}</td>
              <td class="px-3 py-2 text-right font-mono text-slate-900">${fmtInt(x.votes)}</td>
              <td class="px-3 py-2 text-right text-slate-700">${share}</td>
              <td class="px-3 py-2 text-right text-slate-500">${Number.isFinite(x.choiceRank) ? x.choiceRank : "—"}</td>
            </tr>
          `;
        })
        .join("");

      return `
        <details class="group rounded-xl border border-slate-200 bg-white">
          <summary class="cursor-pointer list-none px-4 py-3">
            <div class="flex items-start justify-between gap-4">
              <div>
                <div class="text-sm font-semibold text-slate-900">${esc(contestName)}</div>
                <div class="mt-0.5 text-xs text-slate-500">${esc(r0.contestType || "")}</div>
              </div>
              <div class="hidden sm:block">${headerRight}</div>
            </div>
            <div class="mt-2 sm:hidden">${headerRight}</div>
            <div class="mt-2 text-xs text-slate-500 group-open:hidden">Click to expand</div>
          </summary>

            <div class="mt-4 overflow-hidden rounded-lg border border-slate-200">
              <table class="w-full text-sm">
                <thead class="bg-slate-50 text-xs text-slate-600">
                  <tr>
                    <th class="px-3 py-2 text-left font-semibold">Choice</th>
                    <th class="px-3 py-2 text-right font-semibold">Votes</th>
                    <th class="px-3 py-2 text-right font-semibold">Share</th>
                    <th class="px-3 py-2 text-right font-semibold">Rank</th>
                  </tr>
                </thead>
                <tbody class="bg-white">
                  ${tableRows}
                </tbody>
              </table>
            </div>

            <div class="mt-3 text-xs text-slate-500">
              Fragmentation: <span class="font-mono text-slate-700">${fmtFloat(r0.polarization, 3)}</span>
              <span class="mx-2 text-slate-300">•</span>
              Roll-off rate: <span class="font-mono text-slate-700">${fmtFloat(r0.rolloffRate, 3)}</span>
            </div>
          </div>
        </details>
      `;
    }

    function renderForPrecinct(precinctCodeRaw) {
      const precinctCode = norm(precinctCodeRaw).toUpperCase();

      if (!state.loaded) {
        setReport(`<div class="text-sm text-slate-700">Loading election data…</div>`);
        return;
      }

      const ek = state.activeElectionKey || (state.elections[0] && state.elections[0].key) || "";
      if (!ek) {
        setReport(`<div class="text-sm text-slate-700">No election data available.</div>`);
        return;
      }

      const eMap = state.idx.get(ek);
      const pMap = eMap ? eMap.get(precinctCode) : null;

      if (!precinctCode) {
        setReport(`<div class="text-sm text-slate-700">Select a precinct to populate this report.</div>`);
        return;
      }

      if (!pMap) {
        setReport(`
          <div class="text-sm text-slate-700">
            <div class="font-semibold text-slate-900">No data for ${esc(precinctCode)}</div>
            <div class="mt-1 text-slate-600">This precinct may not participate in the selected election, or results are missing.</div>
          </div>
        `);
        return;
      }

      const meta = state.precinctMeta.get(`${ek}|${precinctCode}`) || {};
      const ballotsCast = meta.ballotsCast;
      const turnout = meta.turnout;
      const reg = meta.registration;

      // Prefer computed turnoutRate, otherwise derive
      const turnoutRate =
        Number.isFinite(meta.turnoutRate)
          ? meta.turnoutRate
          : (Number.isFinite(turnout) && Number.isFinite(reg) && reg > 0 ? turnout / reg : null);

      // contests sorted by vote volume
      const contests = Array.from(pMap.entries())
        .sort((a, b) => contestSortKey(b[1]) - contestSortKey(a[1]));

      const electionLabel = state.elections.find((x) => x.key === ek)?.label || ek;

      const contestBlocks = contests
        .map(([contestName, rows]) => renderContestBlock(contestName, rows))
        .join('<div class="h-3"></div>');

      setReport(`
        <div class="space-y-4">
          <div class="flex flex-col gap-1">
            <div class="text-xs font-semibold uppercase tracking-wide text-slate-500">Selected precinct</div>
            <div class="flex flex-wrap items-end justify-between gap-3">
              <div class="text-lg font-semibold text-slate-900">
                <span class="font-mono">${esc(precinctCode)}</span>
              </div>
              <div class="text-xs text-slate-500">${esc(electionLabel)}</div>
            </div>
          </div>

          <div class="grid gap-3 sm:grid-cols-3">
            <div class="rounded-xl border border-slate-200 bg-white p-4">
              <div class="text-xs font-semibold uppercase tracking-wide text-slate-500">Registered</div>
              <div class="mt-1 text-xl font-semibold text-slate-900">${fmtInt(reg)}</div>
            </div>
            <div class="rounded-xl border border-slate-200 bg-white p-4">
              <div class="text-xs font-semibold uppercase tracking-wide text-slate-500">Ballots cast</div>
              <div class="mt-1 text-xl font-semibold text-slate-900">${fmtInt(ballotsCast)}</div>
            </div>
            <div class="rounded-xl border border-slate-200 bg-white p-4">
              <div class="text-xs font-semibold uppercase tracking-wide text-slate-500">Turnout rate</div>
              <div class="mt-1 text-xl font-semibold text-slate-900">${fmtPct(turnoutRate, 1)}</div>
              <div class="mt-1 text-xs text-slate-500">Turnout: ${fmtInt(turnout)}</div>
            </div>
          </div>

          <div class="pt-1">
            <div class="text-sm font-semibold text-slate-900">Contests</div>
            <div class="mt-2 space-y-3">
              ${contestBlocks}
            </div>
          </div>
        </div>
      `);
    }

    // =========================================================
    // Load + init
    // =========================================================
    async function load() {
      setReport(`<div class="text-sm text-slate-700">Loading election data…</div>`);

      let text = "";
      try {
        const res = await fetch(CFG.csvUrl, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        text = await res.text();
      } catch (err) {
        console.error(err);
        setReport(`
          <div class="text-sm text-red-700">
            Failed to load <span class="font-mono">${esc(CFG.csvUrl)}</span>. Check the path and Quarto resources.
          </div>
        `);
        return;
      }

      const rows = parseCSV(text);
      buildIndexes(rows);

      state.loaded = true;
      state.activeElectionKey = state.elections[0] ? state.elections[0].key : "";

      setElectionSelectOptions();

      // Render if a precinct was already selected by the map script
      const last = (window.UCD_LAST_SELECTED_PRECINCT || "").toString().trim();
      if (last) renderForPrecinct(last);
      else setReport(`<div class="text-sm text-slate-700">Select a precinct to populate this report.</div>`);
    }

    // Election change handler
    if (ui.electionSelect) {
      ui.electionSelect.addEventListener("change", () => {
        state.activeElectionKey = ui.electionSelect.value || "";
        const last = (window.UCD_LAST_SELECTED_PRECINCT || "").toString().trim();
        if (last) renderForPrecinct(last);
        else setReport(`<div class="text-sm text-slate-700">Select a precinct to populate this report.</div>`);
      });
    }

    // Expose hook for the map script
    window.UCDReports = {
      renderForPrecinct,
    };

    load();
  })();
</script>
